<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Alpine Blog]]></title>
  <link href="http://githubdelegate.github.io/atom.xml" rel="self"/>
  <link href="http://githubdelegate.github.io/"/>
  <updated>2016-01-07T17:19:16+08:00</updated>
  <id>http://githubdelegate.github.io/</id>
  <author>
    <name><![CDATA[zy]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[oc转swift 错误记录]]></title>
    <link href="http://githubdelegate.github.io/blog/2016/01/04/oczhuan-swift-cuo-wu-ji-lu/"/>
    <updated>2016-01-04T14:34:43+08:00</updated>
    <id>http://githubdelegate.github.io/blog/2016/01/04/oczhuan-swift-cuo-wu-ji-lu</id>
    <content type="html"><![CDATA[<h2>1.option enum -> OptionSetType</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rightView.autoresizingMask = UIViewAutoresizingFlexibleLeftMargin |UIViewAutoresizingFlexibleTopMargin;
</span><span class='line'>  </span></code></pre></td></tr></table></div></figure>


<p>转</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>self.rightView?.autoresizingMask = [.FlexibleTopMargin,.FlexibleLeftMargin]</span></code></pre></td></tr></table></div></figure>


<ul>
<li><p>MIN -> min</p></li>
<li><p>3.swift 闭包中的循环引用</p>

<blockquote><p><a href="http://southpeak.github.io/blog/2014/06/27/ios-swift-closures-2/">Swift闭包二：循环引用</a></p></blockquote></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS UIAppearance使用]]></title>
    <link href="http://githubdelegate.github.io/blog/2016/01/04/ios-uiappearanceshi-yong/"/>
    <updated>2016-01-04T11:06:33+08:00</updated>
    <id>http://githubdelegate.github.io/blog/2016/01/04/ios-uiappearanceshi-yong</id>
    <content type="html"><![CDATA[<h1>iOS UIAppearance使用</h1>

<h3>为什么要使用 <code>UIAppearance</code></h3>

<p>在iOS 5以前，自定义原生控件的外观并没有原生支持，因此开发人员感觉很麻烦。开发人员经常面临的问题是修改一个控件所有实例的外观。解决这个问题的正确方法是重写一遍控件。但由于这么做非常费时，一些开发人员开始覆盖或混写一些方法，如drawRect:。</p>

<p>从iOS 5开始，苹果通过两个协议（UIAppearance和UIAppearanceContainer）规范了对许多UIKit控件定制的支持。所有遵循UIAppearance协议的UI控件通过定制都可以呈现各种外观。不仅如此，UIAppearance协议甚至允许开发者基于控件所属的区域指定不同的外观。也就是说，当某个控件包含在特定视图中时，可以指定它的外观（如UIBarButtonItem的tintColor）。也可以获取该控件类的外观代理对象，用该代理定制外观来实现，下面来看一个例子</p>

<p>iOS5及其以后提供了一个比较强大的工具UIAppearance，我们通过UIAppearance设置一些UI的全局效果，这样就可以很方便的实现UI的自定义效果又能最简单的实现统一界面风格，它提供如下两个方法。</p>

<p><code>+ (id)appearance</code>
这个方法是统一全部改，比如你设置UINavBar的tintColor，你可以这样写：[[UINavigationBar appearance] setTintColor:myColor];</p>

<p><code>+ (id)appearanceWhenContainedIn:(Class &lt;&gt;)ContainerClass,...</code>
这个方法可设置某个类的改变：例如：设置UIBarButtonItem 在UINavigationBar、UIPopoverController、UITabbar中的效果。就可以这样写
[[UIBarButtonItem appearanceWhenContainedIn:[UINavigationBar class], [UIPopoverController class],[UITabbar class] nil] setTintColor:myPopoverNavBarColor];</p>

<pre><code>请注意＊使用appearance设置UI效果最好采用全局的设置，在所有界面初始化前开始设置，否则可能失效。
</code></pre>

<p>但是它并不是支持所有的UI类。下面列出它支持的类</p>

<p>　　1.UIActivitiIndicatorView</p>

<p>　　2.UIBarButtonItem</p>

<p>　　3.UIBarItem</p>

<p>　　4.UINavgationBar</p>

<p>　　5.UIPopoverControll</p>

<p>　　6.UIProgressView</p>

<p>　　7.UISearchBar</p>

<p>　　8.UISegmentControll</p>

<p>　　9.UISlider</p>

<p>　　10.UISwitch</p>

<p>　　11.UITabBar</p>

<p>　　12.UITabBarItem</p>

<p>　　13.UIToolBar</p>

<p>　　14.UIView</p>

<p>　　15.UIViewController
　　</p>

<h3>自己创建一个可自定义外观的控件</h3>

<p>对于我们自己定义的控件，也可以支持UIAppearance协议，这样我们的控件也能支持自定义了。你只需要写一个设置外观的settor，然后在settor方法后面加上“UI_APPEARANCE_SELECTOR”标记就可以。</p>

<h3>UIAppearance实现原理</h3>

<p>在通过UIAppearance调用“UI_APPEARANCE_SELECTOR”标记的方法来配置外观时，UIAppearance实际上没有进行任何实际调用，而是把这个调用保存起来（在Objc中可以用NSInvocation对象来保存一个调用）。当实际的对象显示之前（添加到窗口上，drawRect:之前），就会对这个对象调用之前保存的调用。当这个setter调用后，你的界面风格自定义就完成了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS多线程一]]></title>
    <link href="http://githubdelegate.github.io/blog/2016/01/02/iosduo-xian-cheng-yi/"/>
    <updated>2016-01-02T15:50:05+08:00</updated>
    <id>http://githubdelegate.github.io/blog/2016/01/02/iosduo-xian-cheng-yi</id>
    <content type="html"><![CDATA[<h2>1.3多线程方案</h2>

<table>
<thead>
<tr>
<th>技术 </th>
<th> 描述 </th>
</tr>
</thead>
<tbody>
<tr>
<td>Operation objects </td>
<td> 一个operation对象是一个任务的包装，可以在子线程中正常的执行。这层包装隐藏了线程的管理，让你专心任务本身。你要把它和operation queue相结合。operation queue可以在多个线程中管理operation对象。  | Content Cell</td>
</tr>
<tr>
<td>GCD </td>
<td> GCD 是另一种使用多线程的方式，能让你专注于你的任务而不用担心线程管理。使用GCD,你设计你的任务，把任务添加到一个queue，queue负责调度你的任务在合适的线程。queue会计算当前可用的资源，让你的任务更高效的执行。  | Content Cell</td>
</tr>
<tr>
<td>Idle-time notifications</td>
<td> 对于一些很短，优先级很低的任务，空闲时间通知会在你的程序空闲的时候执行任务。Cocoa 用<code>NSNotificationQueue</code>提供了支持。 |</td>
</tr>
<tr>
<td>Asynchronous functions</td>
<td>系统接口提供了很多异步函数可以自动同步。这些API使用系统用户进程或者创建线程去执行任务，并把结果给你。|</td>
</tr>
<tr>
<td>Timers</td>
<td>你可以使用timers 在主线程中去执行定期的任务，这些任务|</td>
</tr>
</tbody>
</table>


<h3>1.3.1 线程包装</h3>

<p>在应用层，全部的线程本质上都是一样的。开启一个线程后，线程运行状态有三种：<code>running</code>,<code>ready</code>,<code>blocked</code>。当一个线程当前不是运行，那么它可能是blocked，等待输入，或者是ready，等待调度。线程一直在这些状态中交替，直到退出，进入结束状态。
当你创建一个线程，你必须明确一个入口函数，入口函数构建在线程运行的代码。当函数返回或者你明确的结束线程，线程永远的停止并且会被系统回收。因为线程很消耗内存和时间，所以推荐你的入口函数处理大量的工作，或者创建一个<code>run loop</code>去做一些周期重复的工作。</p>

<h3>1.3.2 Run Loops</h3>

<p> 一个run loop就是用来在线程中管理异步到达的事件的一种机制。一个runloop工作原理就是监控一个或多个事件源。当事件到达，系统唤醒线程，调度事件到runloop，把事件调度给你设置的handlers。如果当前没有事件处理，runloop就把线程sleep。
并不要求你在线程中使用runloop，如果使用runloop可以给用户更好的体验。runloop可以保证线程使用最小的资源长期的存活下去，因为runloop会让线程进入睡眠状态，当线程无事可做的时候。它不需要不断的轮询，避免浪费CPU周期和防止处理器本身从睡觉和节约能源。
配置一个runloop，你不得不开启你的线程，获得一个你的线程的引用，安装你的事件handlers，然后告诉runloop run即可。OS X 的主线程已经配置好了runloop。如果你打算创建一个长期生存的线程，你必须为线程配置runloop。</p>

<h3>1.3.3 同步工具</h3>

<p> 多线程编程的一个最危险的就是多线程间的资源的争夺。如果多个线程尝试使用或修改同样的资源在同一时刻，问题就会出现。
Lock 提供一种狂野的方式保护一个时刻只能被一个线程执行的代码。最常见的锁是互斥锁，
系统还提供了条件变量conditions，用来保证程序中正确的任务执行顺序。一个条件就像门卫，阻塞线程直到条件为真。</p>

<h3>1.3.4 线程间的交互</h3>

<table>
<thead>
<tr>
<th>机制</th>
<th>简介</th>
</tr>
</thead>
<tbody>
<tr>
<td>Direct messaging</td>
<td>Cocoa支持直接在别的线程执行方法</td>
</tr>
<tr>
<td>Global variables, shared memory, and objects</td>
<td></td>
</tr>
<tr>
<td>Condition</td>
<td></td>
</tr>
<tr>
<td>Run loop sources</td>
<td></td>
</tr>
</tbody>
</table>


<h2>3.Run Loops</h2>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS 自动化]]></title>
    <link href="http://githubdelegate.github.io/blog/2016/01/02/title/"/>
    <updated>2016-01-02T10:46:38+08:00</updated>
    <id>http://githubdelegate.github.io/blog/2016/01/02/title</id>
    <content type="html"><![CDATA[<h2></h2>

<p>exceptionForNotification</p>

<p>测试框架specta</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[学习block]]></title>
    <link href="http://githubdelegate.github.io/blog/2015/12/31/xue-xi-bloc/"/>
    <updated>2015-12-31T10:24:12+08:00</updated>
    <id>http://githubdelegate.github.io/blog/2015/12/31/xue-xi-bloc</id>
    <content type="html"><![CDATA[<blockquote><p><a href="https://www.zybuluo.com/MicroCai/note/57603">block没那么难</a></p></blockquote>

<h2>1.block 基本构成</h2>

<h3>2.<code>__block</code> 和 <code>__weak</code> 区别</h3>

<ol>
<li><p><strong>block 在 ARC 和非 ARC 下含义一样吗？
</strong>block 在 ARC 下捕获的变量会被 block retain, 这样可能导致循环引用, 所以必须要使用弱引用才能解决该问题. 而在非 ARC 下, 可以直接使用 __block 说明符修饰变量, 因为在非 ARC 下, block 不会 retain 捕获的变量.</p></li>
<li><p>以下 keywords 有什么区别: assign vs weak, <strong>block vs </strong>weak
assign 和 weak 是用于在声明属性时, 为属性指定内存管理的语义.</p></li>
</ol>


<p>assign 用于简单的赋值, 不改变属性的引用计数, 用于 Objective-C 中的 NSInteger, CGFloat 以及 C 语言中 int, float, double 等数据类型.
weak 用于对象类型, 由于 weak 同样不改变对象的引用计数且不持有对象实例, 当该对象废弃时, 该弱引用自动失效并且被赋值为 nil, 所以它可以用于避免两个强引用产生的循环引用导致内存无法释放的问题.
<strong>block 和 </strong>weak 之间的却是确实极大的, 不过它们都用于修饰变量.</p>

<p>前者用于指明当前声明的变量在被 block 捕获之后, 可以在 block 中改变变量的值. 因为在 block 声明的同时会截获该 block 所使用的全部自动变量的值, 而这些值只在 block 中只具有"使用权"而不具有"修改权". 而 <strong>block 说明符就为 block 提供了变量的修改权.
后者是所有权修饰符, 什么是所有权修饰符? 这里涉及到另一个问题, 因为在 ARC 有效时, id 类型和对象类型同 C 语言中的其他类型不同, 必须附加所有权修饰符. 所有权修饰符一种有 4 种:
</strong>strong
<strong>weak
</strong>unsafe_unretained
<strong>autorelease
</strong>weak 与 weak 的区别只在于, 前者用于变量的声明, 而后者用于属性的声明.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS could not find Foundation module error]]></title>
    <link href="http://githubdelegate.github.io/blog/2015/12/30/ios-could-not-find-foundation-module-error/"/>
    <updated>2015-12-30T14:41:25+08:00</updated>
    <id>http://githubdelegate.github.io/blog/2015/12/30/ios-could-not-find-foundation-module-error</id>
    <content type="html"><![CDATA[<h1>iOS Xcode 编译遇到<code>could not find Foudation module</code> 错误</h1>

<p>在pch 文件中引用 <code>#import &lt;Foundation/Foundation.h&gt;</code> 出错
解决办法：添加<code>#ifdef __OBJC__ 在这里引用 #endif</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS ARC下内存注意]]></title>
    <link href="http://githubdelegate.github.io/blog/2015/12/28/ios-arcxia-nei-cun-zhu-yi/"/>
    <updated>2015-12-28T20:46:03+08:00</updated>
    <id>http://githubdelegate.github.io/blog/2015/12/28/ios-arcxia-nei-cun-zhu-yi</id>
    <content type="html"><![CDATA[<h2>ARC 下内存使用注意</h2>

<ol>
<li></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS 多线程GCD和NSOperation]]></title>
    <link href="http://githubdelegate.github.io/blog/2015/12/28/ios-duo-xian-cheng-gcdhe-nsoperation/"/>
    <updated>2015-12-28T20:30:35+08:00</updated>
    <id>http://githubdelegate.github.io/blog/2015/12/28/ios-duo-xian-cheng-gcdhe-nsoperation</id>
    <content type="html"><![CDATA[<h3>GCD和NSOperation使用说明</h3>

<p>1.<code>NSOperation</code></p>

<p> 1.NSOperation 类是一个抽象类，用来概括一个单独的任务的代码和数据。因为它是抽象类，所以要用他的子类，或者系统定义的子类（<code>NSInvocationOperation</code> &amp;&amp; <code>NSBlockOperation</code>）去执行真正的任务。尽管是抽象类，但是<code>NSOperation</code>的实现包括了重要的逻辑可以用来协调任务的安全执行。这种内建的逻辑可以让你集中精力在任务的实现上，而不是为了保证任务的正确运行而写的各种控制粘合代码。
 一个operaton对象是一个单发对象，意味着它执行任务一次完成后，就不能再执行了。你必须把operations对象添加到operation queue，才能执行它们。一个operation queue执行它的operations即可以通过在子线程中直接执行，也可以间接的使用GCD.
如果你不想使用operation queue，你也可以通过直接调用<code>start</code>方法。因为start 一个不是在ready状态的operation，会导致exception，所以手动的执行operation会给代码带来负担。<code>ready</code>属性依据operation的准备就绪状态。</p>

<p>1.1 <code>Operation Dependencies</code></p>

<p>依赖是一个很方便的方法来让operation按照某种顺序执行。你可以通过<code>addDependency:</code> 和 <code>removeDependency:</code>方法来添加或者删除依赖。默认，一个有依赖的operation ，不能进入准备就绪状态，直到它的所有的依赖的operation执行完。一旦依赖的最后一个Operation 执行完毕，它就进入ready并且可以执行了。
NSOperation的依赖之间并没有区别，不管一个被依赖的operation是成功的执行完成，还是不成功的，（换就话说就是，取消一个operation也是表示一个operation结束。）由你决定一个有依赖的operation是不是继续，当它的依赖operation被取消了，或者没有成功的执行完成。这就要求你在你的operation里面加上额外的错误跟踪机制。</p>

<p>1.2 <code>KVO-Compliant Properties</code></p>

<p><code>NSOperation</code> 类的属性可以使用KVC&amp;KVO.
isCancelled - read-only
isAsynchronous - read-only
isExecuting - read-only
isFinished - read-only
isReady - read-only
dependencies - read-only
queuePriority - readable and writable
completionBlock - readable and writable</p>

<p>尽管你可以给这些属性添加观察者，但是你不应该把这些属性绑定上和界面相关的。因为界面相关的内容必须在主线程中执行。但是一个operation可能在任何一个线程中执行，同理KVO的通知也有可能在任何线程中执行。
如果你自己实现前面的属性，你的实现一定要遵从KVC&amp;KVO,如果你定义了额外的属性，推荐你也让这些属性遵循KVC&amp;KVO。</p>

<p>1.3 <code>Multicore Considerations</code></p>

<p><code>NSOperation</code> 类是支持多核的。所以不需要添加lock也能安全的访问NSOperation对象。这种行为是必要的,因为一个操作通常运行在一个单独的线程的创建和监控。当你自定义了一个NSOperation的子类，你必须保证任何覆盖的昂达保持线程安全。如果你自定义了一些方法，比如自定义的数据访问，你必须保证线程安全，意味着任何的访问变量的操作都必须是同步的，防止潜在数据污染。</p>

<p>1.4 <code>Asynchronous Versus Synchronous Operations</code></p>

<p>如果你计划执行一个operation手动的，你应该设计你的Operation以同步或者异步的方式执行，而不是把它添加到queue中。
Operation默认是同步的方式。在同步的方式中，operation不会创建一个新线程去执行，当你调用<code>start</code>方法的时候，operation在当前线程执行。当start方法返回的时候，任务执行完成。
当你调用一个异步的operation的start方法，start会在对应的任务完成之前返回。一个异步的operation对象有责任在子线程中安排它的任务。operation可以通过直接开启一个新线程，调用一个异步方法，或者使用GCD.如果operation正在执行，方法返回了，这并没有关系，只要operation还在进行中就行。</p>

<p>如果你只要考虑使用queue去执行你的operations。把它们定义成同步的会很简单。如果你要执行你的Operation手动的，所以你可能希望定义你的operation是异步的。定义一个异步的operation要求更多的工作量，因为你必须监控你的任务的运行状态，用KVO通知状态变化。但是定义一个异步的Operation很有用，当你手动执行operaiton并且不希望阻塞调用线程的时候。
当你添加一个operation到一个queue的时候，queue不在乎异步的属性，总是直接在异步线程调用start方法。所以如果你一直通过添加operation到queue的方法去执行operation，根本没有必要让operation是异步的。</p>

<p>1.5 <code>Subclassing Notes</code></p>

<p><code>NSOPeration</code>类提供了基本的逻辑来追踪执行状态，但是必须继承它才能干实际的工作。怎么创建你的子类，依赖于你
怎么设计你的operation，是并发的还是不并发的。</p>

<ul>
<li><p>对于不并发的opeartion，你只需要重写一个<code>main</code>方法：在这个方法中，放置任务需要执行的代码。你应该自己定义一个初始化方法，让创建实例更简单。也可以定义<code>getter</code> <code>setter</code>方法，你必须保证这些方法是多线程安全的。</p></li>
<li><p>对于并发的operation，至少需要重写<code>start</code>,<code>asynchronous</code>,<code>executing</code>,<code>finished</code>方法。在并发操作中，你的start方法要开启operation异步地，不论是创建一个新线程还是调用异步的方法。一旦开启了operation，你的start方法还要更新executing属性状态，发送KVO通知。一旦执行完成或者取消执行了，你的同步的operation对象必须发送KVO通知，对应的<code>isExecuting</code> 和<code>isFInished</code>属性。(如果是取消，更新isFinisheh很重要，尽管Operation没有完整的完成任务)。</p></li>
</ul>


<p>2.<code>NSInvocationOperation</code></p>

<p><code>start</code>方法：这个方法的默认实现是更新operation执行状态，调用<code>main</code>方法。当然这个方法也会检查确保operation可以run。例如，如果cancelled，或者finished，就不会调用main方法直接返回。如果operation当前正在运行或者还没准备好运行，会抛出<code>NSInvalidArgumentException</code>异常。
注意:如果一个operation依赖一些还没finished的operations，那么就认为当前operation还没进入ready状态。
如果你是实现一个同步operation，你必须重写start方法，在start方法里面初始化operation。你自己的start方法不能调用父类的start方法。为了设置运行环境，你的实现必须根据情况改变运行的状态。当operaton开始执行，然后结束运行的时候，要发送KVO通知，<code>isExecting</code> 和<code>isFinished</code>。
如果你想主动主动的执行你的operations，你可以直接调用<code>start</code>方法。然而，对一个已经添加到queue的operation调用start方法是错误的。把一个已经调用过start方法的operation添加到queue，也是错误的。一旦把一个operation添加到queue，queue就会对这个operation全权负责了，你不需要关心了。</p>

<h4><code>NSBlockOperation&amp;NSInvocationOperation</code></h4>

<p><code>NSBlockOperation</code> 管理多个block的同步执行。你可以用这个对象一次执行多个block而不用分开创建不同的operation对象。当执行多个block的时候，只有当全部的block finished才算这个operation finished。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>   
</span><span class='line'>       NSBlockOperation *blockOperation = [NSBlockOperation blockOperationWithBlock:^{
</span><span class='line'>        NSLog(@"1th block--current thread:%@",[NSThread currentThread]);
</span><span class='line'>    }];
</span><span class='line'>    
</span><span class='line'>    // operation的所以block执行完成后，才会执行。在当前线程中执行。
</span><span class='line'>    blockOperation.completionBlock = ^(){
</span><span class='line'>        NSLog(@"blockoperaton 完成啦啦啦啦啦---current thread:%@",[NSThread currentThread]);
</span><span class='line'>    };
</span><span class='line'>    
</span><span class='line'>    [blockOperation addExecutionBlock:^{
</span><span class='line'>        NSLog(@"2th block--current thread:%@",[NSThread currentThread]);
</span><span class='line'>    }];
</span><span class='line'>    
</span><span class='line'>    [blockOperation addExecutionBlock:^{
</span><span class='line'>        NSLog(@"add 3th block--current thread:%@",[NSThread currentThread]);
</span><span class='line'>    }];
</span><span class='line'>    
</span><span class='line'>    // 1.手动start执行，第一个block会在当前线程中执行，其余block会在异步线程中
</span><span class='line'>    // [blockOperation start];
</span><span class='line'>    
</span><span class='line'>    // 2.放到queue中执行，queue会把其中的operation放在异步线程中执行，所以block会全部在异步线程中执行。并且是并发执行。
</span><span class='line'>    [[[NSOperationQueue alloc] init] addOperation:blockOperation];
</span><span class='line'>    
</span><span class='line'>//##---------------------------------------------
</span><span class='line'>    NSInvocationOperation *invocationOperation = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(run:) object:@"123"];
</span><span class='line'>    invocationOperation.completionBlock = ^(){
</span><span class='line'>        NSLog(@"invocation完成--current thread:%@",[NSThread currentThread]);
</span><span class='line'>    };
</span><span class='line'>    
</span><span class='line'>    // 1.手动start执行.在当前线程中执行。
</span><span class='line'>    // [invocationOperation start];
</span><span class='line'>    
</span><span class='line'>    // 2.放到queue中执行，queue会把其中的operation放在异步线程中执行.
</span><span class='line'>    [[[NSOperationQueue alloc] init] addOperation:invocationOperation];
</span></code></pre></td></tr></table></div></figure>


<p>输出结果：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>2015-12-29 15:15:29.222 NSOperationTest[62550:4394450] add 3th block--current thread:&lt;NSThread: 0x796677a0&gt;{number = 4, name = (null)}
</span><span class='line'>2015-12-29 15:15:29.222 NSOperationTest[62550:4394449] 2th block--current thread:&lt;NSThread: 0x79667970&gt;{number = 5, name = (null)}
</span><span class='line'>2015-12-29 15:15:29.222 NSOperationTest[62550:4394436] 1th block--current thread:&lt;NSThread: 0x79667670&gt;{number = 3, name = (null)}
</span><span class='line'>2015-12-29 15:15:29.222 NSOperationTest[62550:4394453] invocationOperaton---current thread:&lt;NSThread: 0x7978c4d0&gt;{number = 6, name = (null)}--obj=123
</span><span class='line'>2015-12-29 15:15:29.225 NSOperationTest[62550:4394449] invocation完成--current thread:&lt;NSThread: 0x79667970&gt;{number = 5, name = (null)}
</span><span class='line'>2015-12-29 15:15:29.225 NSOperationTest[62550:4394453] blockoperaton 完成啦啦啦啦啦---current thread:&lt;NSThread: 0x7978c4d0&gt;{number = 6, name = (null)}
</span></code></pre></td></tr></table></div></figure>


<p>结论：<code>NSBlockOperation</code>添加的block会添加到<code>executionBlocks</code>中，猜测<code>start</code>方法的大概伪代码实现是</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)start
</span><span class='line'>{
</span><span class='line'>    Block block  = executionBlocks.firstObj;
</span><span class='line'>    block(); // 先执行第一个block
</span><span class='line'>
</span><span class='line'>    for (int i = 1; i&lt;executionBlocks.count; i++) {
</span><span class='line'>        dispatch_async(dispatch_get_global_queue(0, 0), ^{
</span><span class='line'>            (block)executionBlocks[i](); // 异步执行剩下的block
</span><span class='line'>        });
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    // 当前面的任务全部完成后调用完成block
</span><span class='line'>    self.completionBlock();
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p>当放入queue中时，就是再异步线程中调用当前operation的 <code>start</code>方法。</p>

<p>2.<code>GCD</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Xcode 不显示程序内存占用状态]]></title>
    <link href="http://githubdelegate.github.io/blog/2015/12/28/xcode-bu-xian-shi-cheng-xu-nei-cun-zhan-yong-zhuang-tai/"/>
    <updated>2015-12-28T15:57:23+08:00</updated>
    <id>http://githubdelegate.github.io/blog/2015/12/28/xcode-bu-xian-shi-cheng-xu-nei-cun-zhan-yong-zhuang-tai</id>
    <content type="html"><![CDATA[<h3>Xcode 突然不显示程序运行的内存占用信息了</h3>

<p>办法：<code>Product</code>-> <code>Scheme</code>-><code>Edit Scheme</code> -> <code>Diagnostic</code>-> <code>取消Enable Zombie Objects</code> 选项。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[对YYKit的理解]]></title>
    <link href="http://githubdelegate.github.io/blog/2015/12/21/dui-yykitde-li-jie/"/>
    <updated>2015-12-21T16:38:04+08:00</updated>
    <id>http://githubdelegate.github.io/blog/2015/12/21/dui-yykitde-li-jie</id>
    <content type="html"><![CDATA[<h3>1.YYKit Foudation中的<code>NSObject+YYAdd</code>分类</h3>

<ul>
<li>C中的可变参数

<blockquote><p><a href="http://blog.csdn.net/edonlii/article/details/8497704">http://blog.csdn.net/edonlii/article/details/8497704</a>
<a href="http://www.cnblogs.com/haoyuanyuan/p/3221463.html">深入C语言可变参数(va_arg,va_list,va_start,va_end,_INTSIZEOF)
</a></p></blockquote></li>
</ul>


<p>1.<code>performSelectorWithArgs</code> 方法：中用到了<code>NSInvocation</code>and<code>NSMethodSignature</code>。
NSInvocation 可以理解成一个发送一个消息，并接收消息返回内容，执行invoke就传递消息，里面包含参数，接受者，返回值。</p>

<p>NSMethodSignature 是一个方法的封装，包括方法的参数类型，个数，返回值类型，返回值长度。</p>

<p>2.<code>+ (BOOL)swizzleInstanceMethod:(SEL)originalSel with:(SEL)newSel</code> 方法。用到了runtime的中交换两个方法的实现。</p>

<blockquote><p><a href="http://blog.csdn.net/yiyaaixuexi/article/details/9374411#t1"> Objective-C的hook方案（一）: Method Swizzling</a></p></blockquote>

<ol>
<li><code>- (void)addObserverBlockForKeyPath:(NSString*)keyPath block:(void (^)(__weak id obj, id oldVal, id newVal))block;</code> KVO 直接block不使用代理模式，简便明朗。
KVO实现原理： 当某个类的对象第一次被观察时，系统就会在运行期动态地创建该类的一个派生类，在这个派生类中重写基类中任何被观察属性的 setter 方法。
派生类在被重写的 setter 方法实现真正的通知机制，就如前面手动实现键值观察那样。这么做是基于设置属性会调用 setter 方法，而通过重写就获得了 KVO 需要的通知机制。当然前提是要通过遵循 KVO 的属性设置方式来变更属性值，如果仅是直接修改属性对应的成员变量，是无法实现 KVO 的。</li>
</ol>


<blockquote><p><a href="http://blog.csdn.net/wzzvictory/article/details/9674431">KVC/KVO原理详解及编程指南</a></p>

<p><a href="http://blog.csdn.net/wzzvictory/article/details/8592492">Objective-C对象之类对象和元类对象（一）</a></p>

<p><a href="http://www.jianshu.com/p/41735c66dccb">Objective-C isa 指针 与 runtime 机制</a></p></blockquote>

<p>4.<code>__weak</code> 和<code>__block</code>的区别</p>

<p><strong>__weak 本身是可以避免循环引用的问题的，但是其会导致外部对象释放了之后，block 内部也访问不到这个对象的问题，我们可以通过在 block 内部声明一个 </strong>strong 的变量来指向 weakObj，使外部对象既能在 block 内部保持住，又能避免循环引用的问题</p>

<p><strong>__block 本身无法避免循环引用的问题，但是我们可以通过在 block 内部手动把 blockObj 赋值为 nil 的方式来避免循环引用的问题。另外一点就是 </strong>block 修饰的变量在 block 内外都是唯一的，要注意这个特性可能带来的隐患。</p>

<p><a href="http://honglu.me/2015/01/06/weak%E4%B8%8Eblock%E5%8C%BA%E5%88%AB/"><strong>weak与</strong>block区别</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS 多线程间同步]]></title>
    <link href="http://githubdelegate.github.io/blog/2015/12/16/ios-duo-xian-cheng-jian-tong-bu/"/>
    <updated>2015-12-16T10:53:50+08:00</updated>
    <id>http://githubdelegate.github.io/blog/2015/12/16/ios-duo-xian-cheng-jian-tong-bu</id>
    <content type="html"><![CDATA[<h2>iOS 多线程同步</h2>

<hr />

<h3>线程同步概念</h3>

<p>  同”字从字面上容易理解为一起动作其实不是，“同”字应是指协同、协助、互相配合。如进程、线程同步，可理解为进程或线程A和B一块配合，A执行到一定程度时要依靠B的某个结果，于是停下来，示意B运行；B依言执行，再将结果给A；A再继续操作。
    所谓同步，就是在发出一个功能调用时，在没有得到结果之前，该调用就不返回，同时其它线程也不能调用这个方法。按照这个定义，其实绝大多数函数都是同步调用（例如sin, isdigit等）。但是一般而言，我们在说同步、异步的时候，特指那些需要其他部件协作或者需要一定时间完成的任务。例如Window API函数SendMessage。该函数发送一个消息给某个窗口，在对方处理完消息之前，这个函数不返回。当对方处理完毕以后，该函数才把消息处理函数所返回的LRESULT值返回给调用者。
    在多线程编程里面，一些敏感数据不允许被多个线程同时访问，此时就使用同步访问技术，保证数据在任何时刻，最多有一个线程访问，以保证数据的完整性。
我们可以通过<code>互斥锁(mutex)</code>，<code>条件变量(condition variable)</code>和<code>读写锁(reader-writer lock)</code> 和<code>信号</code>来同步资源。</p>

<ul>
<li>互斥锁仅允许每次使用一个线程来执行特定的部分代码或者访问特定数据。</li>
<li>读写锁允许对受保护的共享资源进行并发读取和独占写入。要修改资源，线程必须首先获取互斥写锁。只有释放所有的读锁之后，才允许使用互斥写锁。</li>
<li>条件变量会一直阻塞线程，直到特定的条件为真。</li>
<li>计数信号量通常用来协调对资源的访问。使用计数，可以限制访问某个信号的线程数达到指定的计数时，信号将阻塞。</li>
</ul>


<hr />

<h3>iOS多线程同步的办法</h3>

<h4>1.Atomic Operations</h4>

<p>原子操作是对简单的数据类型的最简单的同步方法。用原子操作的好处是不会阻塞正在竞争的线程，这比加锁好。</p>

<h4>2.Locks</h4>

<p>锁是最常用的同步工具。你可以用锁保护一段一次只允许一个线程执行的代码块。比如，一段操作一份关键数据的代码，或者用到一些一次只允许一个用户操作的资源。通过把一个锁放在这段代码两边，可以阻止其他线程修改。
iOS 中可以使用的锁如下代码：</p>

<ul>
<li><code>1.mutex lock</code></li>
</ul>


<pre><code class="`">
  - (void)viewDidLoad {
    [super viewDidLoad];

    self.test = 10;
    pthread_mutex_init(&amp;mutex, NULL);
    pthread_mutex_lock(&amp;mutex);
    self.test+=20;
    printf("test=%d",self.test);
}

- (IBAction)btn1Click:(id)sender {
    dispatch_async(dispatch_get_global_queue(0, 0), ^{
        pthread_mutex_lock(&amp;mutex); // 如果mutex没有释放会在这里等待
        self.test+=10;
        printf("test=%d\n",self.test);
        NSLog(@"current thread:%@",[NSThread currentThread]);
        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
            pthread_mutex_unlock(&amp;mutex);
        });
    });
}

    - (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event
    {
        pthread_mutex_unlock(&amp;mutex);
    }
</code></pre>

<p> 输出：</p>

<pre><code class="`">
test=30test=40
2015-12-16 18:07:27.297 threadSynTest[5908:374571] current thread:&lt;NSThread: 0x7b246080&gt;{number = 2, name = (null)}
test=50
2015-12-16 18:07:28.392 threadSynTest[5908:374574] current thread:&lt;NSThread: 0x7b2b6ce0&gt;{number = 3, name = (null)}
test=60
2015-12-16 18:07:29.415 threadSynTest[5908:374570] current thread:&lt;NSThread: 0x7b28a530&gt;{number = 4, name = (null)}
test=70
2015-12-16 18:07:30.423 threadSynTest[5908:374575] current thread:&lt;NSThread: 0x7b26c700&gt;{number = 5, name = (null)}
</code></pre>

<ul>
<li><code>2.NSLock</code></li>
</ul>


<p> 注意: <code>NSLock</code> 在<code>POSIX threads</code> 基础上实现的。当对一个NSLock 对象调用<code>unlock</code>方法，你必须要保证和给<code>NSLock</code>对象调用<code>lock</code>方法在同一个线程。在不同的线程里unlock会导致未知的错误。连续两次调用lock方法会导致死锁。如果要递归的加锁，用<code>NSRecursiveLock</code>。对一个未加锁的lock 调用<code>unlock</code>是不正确的，要修正。</p>

<p> <code>tryLock</code> :尝试加锁，并且会立即返回，成功返回YES，不会阻塞。
 <code>lock</code> 方法: 加锁，如果当前是在锁的状态，当前线程的会阻塞，直到加锁</p>

<ul>
<li><code>3.@synchronized</code></li>
</ul>


<p> <code>@synchronized</code> 指令可以非常方便的创建互斥锁，它会像其他互斥锁一样防止不同线程在同一时刻获得相同的锁。但是你并不需要创建<code>mutex lock</code>或<code>NSLock</code> 对象，相反你只需要简单用一个OC 对象作为一个lock token.
传递给@synchronized指令的对象是唯一的，用来区别被保护的代码块。如果你在不同的线程执行这个指令，并用不同的对象作为参数，每个线程会产生自己的锁，并且会继续运行，相互之间不会相互影响。然而，如果你传递相同的对象作为参数，一个线程会先获得锁，另外一个会阻塞等待到第一个执行完成。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>- (IBAction)synchrinized:(id)sender {
</span><span class='line'>    
</span><span class='line'>    dispatch_async(dispatch_get_global_queue(0, 0), ^{
</span><span class='line'>        @synchronized(self) {
</span><span class='line'>            [self changeValue];
</span><span class='line'>            [NSThread sleepUntilDate:[NSDate dateWithTimeIntervalSinceNow:3]];
</span><span class='line'>        }
</span><span class='line'>        
</span><span class='line'>        dispatch_async(dispatch_get_main_queue(), ^{
</span><span class='line'>            @synchronized(self) {
</span><span class='line'>                [self changeValue];
</span><span class='line'>            }
</span><span class='line'>        });
</span><span class='line'>    });
</span><span class='line'>    
</span><span class='line'>    @synchronized(self) {
</span><span class='line'>        [self changeValue];
</span><span class='line'>        [NSThread sleepUntilDate:[NSDate dateWithTimeIntervalSinceNow:3]];
</span><span class='line'>    }
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>2015-12-16 19:51:18.829 threadSynTest[6717:497526] test==20---current thread:&lt;NSThread: 0x7ba3af80&gt;{number = 1, name = main}
</span><span class='line'>2015-12-16 19:51:21.831 threadSynTest[6717:497574] test==30---current thread:&lt;NSThread: 0x7b84d860&gt;{number = 2, name = (null)}
</span><span class='line'>2015-12-16 19:51:24.837 threadSynTest[6717:497526] test==40---current thread:&lt;NSThread: 0x7ba3af80&gt;{number = 1, name = main}
</span></code></pre></td></tr></table></div></figure>


<ul>
<li><code>4.NSRecursiveLock</code></li>
</ul>


<p> <code>NSRecursiveLock</code> 定义一种可以被同一个线程多次加锁而且不会引起死锁.递归锁会记录当前被成功加了多少次锁，只有加锁和解锁次数一样，平衡时，这个锁最终才被释放，其他线程才能获得这个锁。递归锁通常用在递归函数内部防止递归操作阻塞线程。当然你也可以用在非递归的场合。</p>

<pre><code class="`">
- (void)recursiveFun:(int)count
{
    [self.recursiveLock lock];
    [self changeValue];
    if (count != 0) {
        count--;
        [self recursiveFun:count];
    }

    [self.recursiveLock unlock];
}
</code></pre>

<ul>
<li><code>5.NSConditionLock</code></li>
</ul>


<p><code>NSConditionLock</code> 定义了一个可以通过特殊的值来锁和解锁的互斥锁。不要和<code>Condition</code>搞混，虽然这种方式和条件很像，但是实现完全不同。特别是当线程之间需要需要按照一个特殊的顺序执行任务的时候，你应该使用<code>NSConditionLock</code>,比如一个线程生产数据，另一个消费数据。当生产者正在执行的时候，消费者用条件请求锁。当生产者完成后，解锁并设置条件，唤醒消费线程，去消费数据。
<code>NSConditionLock</code>的加锁和解锁方法可以各种组合。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>- (void)sendSharedData{
</span><span class='line'>    [self.conditionLock lock];
</span><span class='line'>    [self.sharedArray addObject:@1];
</span><span class='line'>    NSLog(@"添加数据 thread:%@",[NSThread currentThread]);
</span><span class='line'>    [self.conditionLock unlockWithCondition:1];
</span><span class='line'>    [NSThread sleepUntilDate:[NSDate dateWithTimeIntervalSinceNow:0.3]];
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>- (IBAction)conditionlock:(id)sender {
</span><span class='line'>    dispatch_async(dispatch_get_global_queue(0, 0), ^{
</span><span class='line'>        while (1) {
</span><span class='line'>            [self.conditionLock lockWhenCondition:1];
</span><span class='line'>            [self.sharedArray removeObjectAtIndex:0];
</span><span class='line'>            NSLog(@"消耗一个数据 thread:%@",[NSThread currentThread]);
</span><span class='line'>            BOOL isEmpty = self.sharedArray.count == 0 ? YES : NO;
</span><span class='line'>            [self.conditionLock unlockWithCondition:(isEmpty ? 0 : 1)];
</span><span class='line'>            [NSThread sleepUntilDate:[NSDate dateWithTimeIntervalSinceNow:2]];
</span><span class='line'>        }
</span><span class='line'>    });
</span><span class='line'>    
</span><span class='line'>    dispatch_async(dispatch_get_global_queue(0, 0), ^{
</span><span class='line'>        NSTimer *timer = [NSTimer scheduledTimerWithTimeInterval:0.5 target:self selector:@selector(sendSharedData) userInfo:nil repeats:YES];
</span><span class='line'>        [[NSRunLoop currentRunLoop] run];
</span><span class='line'>    });
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure>


<h4>Conditions 条件变量</h4>

<p>条件是另一种信号量，当满足某个条件的时候能允许其他线程运行。条件信号量主要用来表示某个资源可用个数，和保证线程安装固定的顺序运行。当一个线程需要某个condition的时候，会一直阻塞等待，直到只有当其他线程改变了条件信号量。互斥和条件信号量之间的区别是用条件信号量允许多个线程同时获得条件，运行。条件信号量就像门卫一样，根据资源的多少，决定让不同的线程可以进入。</p>

<h4>使用<code>Conditions</code></h4>

<p>条件是一种特殊类型的锁，它可以用来同步各个操作   顺序。条件和同步锁之间的区别很微妙。一个线程等待一个条件会阻塞，直到另外一个线程明确的发出条件信号。</p>

<ul>
<li><code>1.POSIX Conditions</code>
  <code>POSIX</code> 线程条件锁要求同时使用条件和互斥。运行时互斥锁约束条件，等待信号的线程使用同样的互斥和条件变量。</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (IBAction)distributedlock:(id)sender {
</span><span class='line'>    dispatch_async(dispatch_get_global_queue(0, 0), ^{
</span><span class='line'>        [self waitOnConditionfun];
</span><span class='line'>    });
</span><span class='line'>    dispatch_async(dispatch_get_global_queue(0, 0), ^{
</span><span class='line'>        [self signalThreadCondition];
</span><span class='line'>    });
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>- (void)waitOnConditionfun{
</span><span class='line'>    
</span><span class='line'>    // mutex 如果等待线程先获得mutex，加锁。那signal如何获得锁，又如何加锁呢。哦如果不成功，直接就解锁
</span><span class='line'>    pthread_mutex_lock(&mutex);
</span><span class='line'>    while (ready_to_go) {
</span><span class='line'>        NSLog(@"wait--thread:%@",[NSThread currentThread]);
</span><span class='line'>        pthread_cond_wait(&condition, &mutex);
</span><span class='line'>    }
</span><span class='line'>    ready_to_go = false;
</span><span class='line'>    pthread_mutex_unlock(&mutex);
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>- (void)signalThreadCondition{
</span><span class='line'>
</span><span class='line'>    // At this point, there should be work for the other thread to do.
</span><span class='line'>    pthread_mutex_lock(&mutex);
</span><span class='line'>    ready_to_go = true;
</span><span class='line'>    // Signal the other thread to begin work.
</span><span class='line'>    pthread_cond_signal(&condition);
</span><span class='line'>    NSLog(@"signal--thread:%@",[NSThread currentThread]);
</span><span class='line'>    pthread_mutex_unlock(&mutex);
</span><span class='line'>}
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li><code>2.NSCondition</code></li>
</ul>


<p><code>NSCondition</code>提供了和<code>POSIX condition</code>相同的功能，但是把请求锁和条件封装成一个对象，结果就是你只用它就可以实现互斥加锁和条件等待。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>- (IBAction)nscondition:(id)sender {
</span><span class='line'>    
</span><span class='line'>    dispatch_async(dispatch_get_global_queue(0, 0), ^{
</span><span class='line'>        while (1) {
</span><span class='line'>            [self.condition lock];
</span><span class='line'>            while (timeToWork &lt;= 0) {
</span><span class='line'>                [self.condition wait];
</span><span class='line'>            }
</span><span class='line'>            timeToWork--;
</span><span class='line'>            NSLog(@"消费数据--thread:%@",[NSThread currentThread]);
</span><span class='line'>            [self.condition unlock];
</span><span class='line'>        }
</span><span class='line'>    });
</span><span class='line'>
</span><span class='line'>    dispatch_async(dispatch_get_global_queue(0, 0), ^{
</span><span class='line'>        while (1) {
</span><span class='line'>            [self.condition lock];
</span><span class='line'>            timeToWork++;
</span><span class='line'>            NSLog(@"添加数据--thread:%@",[NSThread currentThread]);
</span><span class='line'>            [self.condition signal];
</span><span class='line'>            [self.condition unlock];
</span><span class='line'>            [NSThread sleepUntilDate:[NSDate dateWithTimeIntervalSinceNow:1]];
</span><span class='line'>        }
</span><span class='line'>    });
</span><span class='line'>}
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure>


<hr />

<h3>线程安全设计技巧</h3>

<ul>
<li>1.避免同步</li>
</ul>


<p>同步工具不是万灵药，锁用的太多会导致性能低于没有使用同步的程序。寻找线程安全和性能的平衡是需要经验。实现同步最好的方法是减小线程间的交互，让同步任务相互独立。如果每个任务操作自己私有数据，就不需要使用锁来保护数据。如果不同的任务共享一块数据，你可以尝试把数据分割，或复制一份数据，虽然这也消耗性能，你可以再决定前权衡一下。</p>

<ul>
<li>2.理解同步的限制</li>
</ul>


<p>同步工具只有被所有的线程一直使用才能最有效。如果创建一个互斥锁用来限制对某个资源的访问，你的所以线程必须请求相同的互斥变量才能操作这个数据。如果没达到这个效果，是一个程序员的错误！！！！</p>

<ul>
<li>3.正确编码的风险</li>
</ul>


<p>当使用锁的时候，你必须非常的小心的实现你的代码。因为锁可能看起来很好的实现了，但是还是存在安全问题。看下面的例子，</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSLock* arrayLock = GetArrayLock();
</span><span class='line'>NSMutableArray* myArray = GetSharedArray();
</span><span class='line'>id anObject;
</span><span class='line'> 
</span><span class='line'>[arrayLock lock];
</span><span class='line'>anObject = [myArray objectAtIndex:0];
</span><span class='line'>[arrayLock unlock];
</span><span class='line'> 
</span><span class='line'>[anObject doSomething];
</span></code></pre></td></tr></table></div></figure>


<p>上面的代码，因为array 是可变的，这个lock会一直保护这个array，知道你得到<code>anobject</code>,而且因为anobject 是不可变的，所以<code>[anObject doSomething];</code>不需要锁的保护。但是这段代码有个问题，就是当获得了<code>anb=object</code>后，但是还没执行<code>[anObject doSomething];</code>之前，另外一个线程获得了lock并且把<code>myarray</code>里面的元素全部删掉了，iOS没有内存垃圾机制的，所以<code>anobject</code>指向的对象会被释放，<code>anobject</code>指针会指向一个非法的地址，解决这个问题，你可能会把<code>[anObject doSomething];</code>也放在锁里面，但是这会消耗很长时间，导致其他线程会长时间的等待。正确的做法应该是，保证<code>anobject</code>不会被释放.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>NSLock* arrayLock = GetArrayLock();
</span><span class='line'>NSMutableArray* myArray = GetSharedArray();
</span><span class='line'>id anObject;
</span><span class='line'> 
</span><span class='line'>[arrayLock lock];
</span><span class='line'>anObject = [myArray objectAtIndex:0];
</span><span class='line'>[anObject retain];
</span><span class='line'>[arrayLock unlock];
</span><span class='line'> 
</span><span class='line'>[anObject doSomething];
</span><span class='line'>[anObject release];
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>4.小心死锁活锁</li>
</ul>


<p>任何时候一个线程一次想要获取多于一个锁，都有死锁的可能。死锁是两个线程分别获得一个锁后，又想去得到另外一个线程的锁。结果就是每个线程都会一直阻塞下去。以下是对死锁和活锁的形象描述。 现有个过道，两个人宽，两侧迎面走来两个人A和B。 死锁的情况： A和B都不是讲礼貌的人，都不愿给别人让路，所以A和B都在等对方让路，导致谁也过不去。 活锁的情况： A和B都是很讲礼貌的人，都主动给别人让路。A往左移，同时B往右移；A往右移，同时B往左移。 A和B在移动的时候，同时挡住对方，导致谁也过不去</p>

<ul>
<li><p>5.正确的使用验证变量</p>

<p>  如果你已经使用了互斥锁保护一段代码，就不要再使用验证关键字去保护代码中重要变量。互斥包括一个内存栅栏去确保读取和写入操作的次序。添加一个验证变量会导致强制读取值每次，降低性能。如果一个互斥锁足够的话，就不要再使用了。</p></li>
</ul>


<hr />

<h3>线程安全总结</h3>

<hr />

<h3>不同方法使用的场合，优缺点</h3>

<p>未完待续！！</p>

<p> <a href="https://github.com/githubdelegate/iOS-Thread-Synchronization.git">测试代码</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[swift 中单例的实现]]></title>
    <link href="http://githubdelegate.github.io/blog/2015/12/14/swift-zhong-dan-li-de-shi-xian/"/>
    <updated>2015-12-14T18:54:44+08:00</updated>
    <id>http://githubdelegate.github.io/blog/2015/12/14/swift-zhong-dan-li-de-shi-xian</id>
    <content type="html"><![CDATA[<h1>Swift单例</h1>

<p>Use the <strong>class constant</strong> approach if you are using Swift 1.2 or above and the <strong>nested struct</strong> approach if you need to support earlier versions._</p>

<p>An exploration of the Singleton pattern in Swift. All approaches below support lazy initialization and thread safety.</p>

<p>Issues and pull requests welcome.</p>

<h3>Approach A: Class constant</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class SingletonA {
</span><span class='line'>    
</span><span class='line'>    static let sharedInstance = SingletonA()
</span><span class='line'>    
</span><span class='line'>    init() {
</span><span class='line'>        println("AAA");
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>This approach supports lazy initialization because Swift lazily initializes class constants (and variables), and is thread safe by the definition of <code>let</code>.</p>

<p>Class constants were introduced in Swift 1.2. If you need to support an earlier version of Swift, use the nested struct approach below or a global constant.</p>

<h3>Approach B: Nested struct</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class SingletonB {
</span><span class='line'>    
</span><span class='line'>    class var sharedInstance: SingletonB {
</span><span class='line'>        struct Static {
</span><span class='line'>            static let instance: SingletonB = SingletonB()
</span><span class='line'>        }
</span><span class='line'>        return Static.instance
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>在类变量里嵌套一个 <code>Static</code> 结构体。
<code>Static</code> 封装了一个静态的常量，通过 static 定义意味着这个属性只存在一个，注意 Swift 中 static 的变量是延时加载的，意味着 Instance 直到需要的时候才会被创建。同时再注意一下，因为它是一个常量，所以一旦创建之后不会再创建第二次。这些就是单例模式的核心所在：一旦初始化完成，当前类存在一个实例对象，初始化方法就不会再被调用。</p>

<p>Here we are using the static constant of a nested struct as a class constant. This is a workaround for the lack of static class constants in Swift 1.1 and earlier, and still works as a workaround for the lack of static constants and variables in functions.</p>

<h3>Approach C: dispatch_once</h3>

<p>The traditional Objective-C approach ported to Swift.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class SingletonC {
</span><span class='line'>    
</span><span class='line'>    class var sharedInstance: SingletonC {
</span><span class='line'>        struct Static {
</span><span class='line'>            static var onceToken: dispatch_once_t = 0
</span><span class='line'>            static var instance: SingletonC? = nil
</span><span class='line'>        }
</span><span class='line'>        dispatch_once(&Static.onceToken) {
</span><span class='line'>            Static.instance = SingletonC()
</span><span class='line'>        }
</span><span class='line'>        return Static.instance!
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>I&rsquo;m fairly certain there&rsquo;s no advantage over the nested struct approach but I&rsquo;m including it anyway as I find the differences in syntax interesting.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[转：iOS中的正则表达式]]></title>
    <link href="http://githubdelegate.github.io/blog/2015/12/03/zhuan-:ioszhong-de-zheng-ze-biao-da-shi/"/>
    <updated>2015-12-03T10:15:22+08:00</updated>
    <id>http://githubdelegate.github.io/blog/2015/12/03/zhuan-:ioszhong-de-zheng-ze-biao-da-shi</id>
    <content type="html"><![CDATA[<h1>转自lady-奕奕：<a href="http://my.oschina.net/u/1245365/blog/376517">正则表达式在iOS中的运用</a></h1>

<h4>一、什么是正则表达式</h4>

<pre><code>  正则表达式，又称正规表示法，是对字符串操作的一种逻辑公式。正则表达式可以检测给定的字符串是否符合我们定义的逻辑，也可以从字符串中获取我们想要的特定部分。它可以迅速地用极简单的方式达到字符串的复杂控制。
</code></pre>

<h4>二、正则表达式的语法</h4>

<p>看一个过滤纯数字的例子</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (BOOL)validateNumber:(NSString *) textString
</span><span class='line'>{
</span><span class='line'>    NSString* number=@"^[0-9]+$";
</span><span class='line'>    NSPredicate *numberPre = [NSPredicate predicateWithFormat:@"SELF MATCHES %@",number];
</span><span class='line'>    return [numberPre evaluateWithObject:textString];
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>其中下述语句就是一个正则表达式</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@"^[0-9]+$"
</span></code></pre></td></tr></table></div></figure>


<p>它代表了字符串中只能包含>=1个0-9的数字，语法是不是有一些怪异？</p>

<pre><code> 下面我们先撇开iOS中的正则表达式的语法，用通俗的正则表达式语法来为介绍一下。（iOS语法与通俗的正则表达式语法相同，不同在于对转义字符的处理上(语言类的都相同)）
</code></pre>

<p>语法：</p>

<pre><code>首先，符号'^'和'$'。他们分别指出一个字符串的开始和结束。eg：
"^one"：表示所有以"one"开始的字符串（"one cat"，"one123"，·····）；
类似于:- (BOOL)hasPrefix:(NSString *)aString;
"a dog$"：表示所以以"a dog"结尾的字符串（"it is a dog"，·····）；
类似于:- (BOOL)hasSuffix:(NSString *)aString;
"^apple$"：表示开始和结尾都是"apple"的字符串，这个是唯一的~；
"banana"：表示任何包含"banana"的字符串。
类似于 iOS8的新方法- (BOOL)containsString:(NSString *)aString,搜索子串用的。
'*'，'+'和'?'这三个符号，表示一个或N个字符重复出现的次数。它们分别表示“没有或
更多”（[0,+∞]取整），“一次或更多”（[1,+∞]取整），“没有或一次”（[0,1]取整）。下面是几个例子：
"ab*"：表示一个字符串有一个a后面跟着零个或若干个b（"a", "ab", "abbb",……）；
"ab+"：表示一个字符串有一个a后面跟着至少一个b或者更多（ "ab", "abbb",……）；
"ab?"：表示一个字符串有一个a后面跟着零个或者一个b（ "a", "ab"）；
"a?b+$"：表示字符串以零个或一个a跟着一个或几个b结尾（ "b", "ab","bb","abb",……）。
可以用大括号括起来（{}），表示一个重复的具体范围。例如
"ab{4}"：表示一个字符串有一个a跟着4个b（"abbbb"）；
"ab{1,}"：表示一个字符串有一个a跟着至少1个b（"ab","abb","abbb",……)；
"ab{3,4}"：表示一个字符串有一个a跟着3到4个b（"abbb","abbbb")。
那么，“*”可以用{0，}表示，“+”可以用{1，}表示，“?”可以用{0，1}表示
注意：可以没有上限，但是不能没有下限！例如“ab{,5}”是错误的写法
" | "表示“或”操作：
"a|b"：表示一个字符串里有"a"或者"b"；
"(a|bcd)ef"：表示"aef"或"bcdef"；
"(a|b)*c"：表示一串"a""b"混合的字符串后面跟一个"c"；

方括号"[ ]"表示在括号内的众多字符中，选择1-N个括号内的符合语法的字符作为结果，例如
"[ab]"：表示一个字符串有一个"a"或"b"（相当于"a|b"）；
"[a-d]"：表示一个字符串包含小写的'a'到'd'中的一个（相当于"a|b|c|d"或者"[abcd]"）；
"^[a-zA-Z]"：表示一个以字母开头的字符串；
"[0-9]a"：表示a前有一位的数字；
"[a-zA-Z0-9]$"：表示一个字符串以一个字母或数字结束。
"."匹配除“\r\n”之外的任何单个字符：
"a.[a-z]"：表示一个字符串有一个"a"后面跟着一个任意字符和一个小写字母；
"^.{5}$"：表示任意1个长度为5的字符串；

"\num" 其中num是一个正整数。表示"\num"之前的字符出现相同的个数，例如
"(.)\1"：表示两个连续的相同字符。
"10\{1,2\}” : 表示数字1后面跟着1或者2个0 ("10","100")。
" 0\{3,\} " 表示数字为至少3个连续的0 （“000”，“0000”，······）。
在方括号里用'^'表示不希望出现的字符，'^'应在方括号里的第一位。
"@[^a-zA-Z]@"表示两个"@"中不应该出现字母）。

常用的还有：
" \d "匹配一个数字字符。等价于[0-9]。
“ \D”匹配一个非数字字符。等价于[^0-9]。
" \w "匹配包括下划线的任何单词字符。等价于“[A-Za-z0-9_]”。
“ \W ”匹配任何非单词字符。等价于“[^A-Za-z0-9_]”。
</code></pre>

<p><strong>iOS中书写正则表达式，碰到转义字符，多加一个“\”,例如：全数字字符：@&ldquo;^\d+$&rdquo;</strong></p>

<h4>三、iOS中正则表达式</h4>

<p>1.正则表达式与NSPredicate连用，eg：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (BOOL)validateNumber:(NSString *) textString
</span><span class='line'>{
</span><span class='line'>    NSString* number=@"^[0-9]+$";
</span><span class='line'>    NSPredicate *numberPre = [NSPredicate predicateWithFormat:@"SELF MATCHES %@",number];
</span><span class='line'>    return [numberPre evaluateWithObject:textString];
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>2.NSString方法</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (NSRange)rangeOfString:(NSString *)aString options:(NSStringCompareOptions)mask;
</span><span class='line'>NSString *searchText = @"rangeOfString";
</span><span class='line'>NSRange range = [searchText rangeOfString:@"^[0-9]+$" options:NSRegularExpressionSearch];
</span><span class='line'>if (range.location != NSNotFound) {
</span><span class='line'>   NSLog(@"range ：%@", [searchText substringWithRange:range]);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>3.正则表达式类（NSRegularExpression）</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSString *searchText = @"you want to match";    
</span><span class='line'>NSError *error = NULL;
</span><span class='line'>NSRegularExpression *regex = [NSRegularExpression regularExpressionWithPattern:@"^[0-9]+$" options:NSRegularExpressionCaseInsensitive error:&error];
</span><span class='line'>NSTextCheckingResult *result = [regex firstMatchInString:searchText options:0 range:NSMakeRange(0, [searchText length])];
</span><span class='line'>if (result) {
</span><span class='line'>   NSLog(@"%@", [searchText substringWithRange:result.range]);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h4>四、常用的正则表达式</h4>

<pre><code>以下红色字符串是常用的正则表达式（以下正则表达式来自百度百科） 


1.验证用户名和密码："^[a-zA-Z]\w{5,15}$" 
2.验证电话号码：（"^(\\d{3,4}-)\\d{7,8}$"）
eg：021-68686868  0511-6868686；
3.验证手机号码："^1[3|4|5|7|8][0-9]\\d{8}$"；
4.验证身份证号（15位或18位数字）："\\d{14}[[0-9],0-9xX]"；
5.验证Email地址：("^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\.\\w+([-.]\\w+)*$")；
6.只能输入由数字和26个英文字母组成的字符串：("^[A-Za-z0-9]+$") ;
7.整数或者小数：^[0-9]+([.]{0,1}[0-9]+){0,1}$
8.只能输入数字："^[0-9]*$"。
9.只能输入n位的数字："^\\d{n}$"。
10.只能输入至少n位的数字："^\\d{n,}$"。
11.只能输入m~n位的数字："^\\d{m,n}$"。
12.只能输入零和非零开头的数字："^(0|[1-9][0-9]*)$"。
13.只能输入有两位小数的正实数："^[0-9]+(.[0-9]{2})?$"。
14.只能输入有1~3位小数的正实数："^[0-9]+(\.[0-9]{1,3})?$"。
15.只能输入非零的正整数："^\+?[1-9][0-9]*$"。
16.只能输入非零的负整数："^\-[1-9][]0-9"*$。
17.只能输入长度为3的字符："^.{3}$"。
18.只能输入由26个英文字母组成的字符串："^[A-Za-z]+$"。
19.只能输入由26个大写英文字母组成的字符串："^[A-Z]+$"。
20.只能输入由26个小写英文字母组成的字符串："^[a-z]+$"。
21.验证是否含有^%&amp;',;=?$\"等字符："[^%&amp;',;=?$\x22]+"。
22.只能输入汉字："^[\u4e00-\u9fa5]{0,}$"。
23.验证URL："^http://([\\w-]+\.)+[\\w-]+(/[\\w-./?%&amp;=]*)?$"。
24.验证一年的12个月："^(0?[1-9]|1[0-2])$"正确格式为："01"～"09"和"10"～"12"。
25.验证一个月的31天："^((0?[1-9])|((1|2)[0-9])|30|31)$"正确格式 为；"01"～"09"、"10"～"29"和“30”~“31”。
26.获取日期正则表达式：\\d{4}[年|\-|\.]\\d{\1-\12}[月|\-|\.]\\d{\1-\31}日?
评注：可用来匹配大多数年月日信息。
27.匹配双字节字符(包括汉字在内)：[^\x00-\xff]
评注：可以用来计算字符串的长度（一个双字节字符长度计2，ASCII字符计1）
28.匹配空白行的正则表达式：\n\s*\r
评注：可以用来删除空白行
29.匹配HTML标记的正则表达式：&lt;(\S*?)[^&gt;]*&gt;.*?&lt;/&gt;|&lt;.*? /&gt;
评注：网上流传的版本太糟糕，上面这个也仅仅能匹配部分，对于复杂的嵌套标记依旧无能为力
30.匹配首尾空白字符的正则表达式：^\s*|\s*$
评注：可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式
31.匹配网址URL的正则表达式：[a-zA-z]+://[^\s]*
评注：网上流传的版本功能很有限，上面这个基本可以满足需求
32.匹配帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$
评注：表单验证时很实用
33.匹配腾讯QQ号：[1-9][0-9]\{4,\}
评注：腾讯QQ号从10 000 开始
34.匹配中国邮政编码：[1-9]\\d{5}(?!\d)
评注：中国邮政编码为6位数字
35.匹配ip地址：((2[0-4]\\d|25[0-5]|[01]?\\d\\d?)\.){3}(2[0-4]\\d|25[0-5]|[01]?\\d\\d?)。
</code></pre>

<h4>五、正则表达式练习网站</h4>

<ol>
<li><a href="http://regexper.com/">Regexper</a> 图形化的显示正则表达式</li>
<li><a href="http://tool.oschina.net/regex">在线正则表达式测试</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ios-jenkins构建]]></title>
    <link href="http://githubdelegate.github.io/blog/2015/11/24/ios-jenkinsgou-jian/"/>
    <updated>2015-11-24T10:12:57+08:00</updated>
    <id>http://githubdelegate.github.io/blog/2015/11/24/ios-jenkinsgou-jian</id>
    <content type="html"><![CDATA[<h2>iOS SDK自动化构建</h2>

<ol>
<li>C库代码引用
 C库文件太多，而且里面有很多文件不能引用到项目中，不然会导致编译失败，以前使用的办法是先全部引入再删除部分文件，太麻烦了，想通过修改配置文件的方式</li>
<li>Framework的引用</li>
<li>Configure文件 设置buildSetting</li>
<li>自动测试批量测试测试报告生成</li>
<li>MAC 小软件自动生成SDK Demo</li>
<li>jenkins的自动构建</li>
<li>jenkins 自动打包生成ipa上传测试</li>
<li>自动生成Xcode工程，</li>
</ol>


<hr />

<p> # 测试项目直接包含SDK工程</p>

<ol>
<li><code>.mm</code></li>
<li>引用<code>Framework</code> 这个可以后面通过修改xc配置文件完成</li>
<li><code>User Search Header</code> 这个可以通过<code>config</code> 配置文件完成。</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS UDP发广播,接收,TCP监听]]></title>
    <link href="http://githubdelegate.github.io/blog/2015/11/18/iosudpfa-yan-bo-hou-jian-li-tcplian-jie/"/>
    <updated>2015-11-18T11:30:45+08:00</updated>
    <id>http://githubdelegate.github.io/blog/2015/11/18/iosudpfa-yan-bo-hou-jian-li-tcplian-jie</id>
    <content type="html"><![CDATA[<p>iOS 手机端先发送UDP广播，硬件设备端收到后，建立TCP连接，然后手机端读取硬件设备发送的信息。</p>

<hr />

<p>1.UDP广播</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>- (void)viewDidAppear:(BOOL)animated
</span><span class='line'>{
</span><span class='line'>    [super viewDidAppear:animated];
</span><span class='line'>    
</span><span class='line'>     // 1.开始发送udp
</span><span class='line'>    [self setupUdpClient];
</span><span class='line'>    
</span><span class='line'>    // 2.开启定时器，每个一秒发送一次
</span><span class='line'>    self.sendTimer = [NSTimer scheduledTimerWithTimeInterval:1 target:self selector:@selector(p_sendUdp) userInfo:nil repeats:YES];
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>- (void)setupUdpClient
</span><span class='line'>{
</span><span class='line'>    NSError *error;
</span><span class='line'>    _sendUdp = [[AsyncUdpSocket alloc] initWithDelegate:self];
</span><span class='line'>    [_sendUdp enableBroadcast:YES error:&error]; // 开启广播
</span><span class='line'>    if (![self checkError:error]) {
</span><span class='line'>        return;
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    [_sendUdp bindToPort:9997 error:&error]; // 绑定端口
</span><span class='line'>    if (![self checkError:error]) {
</span><span class='line'>        return;
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>- (BOOL)p_sendUdp
</span><span class='line'>{
</span><span class='line'>    NSString *sendStr = [NSString stringWithFormat:@"{\"ip\":\"\%@\"}",[Helper getIPAddress]]; // 发送本机IP地址
</span><span class='line'>    NSData *sendData = [sendStr dataUsingEncoding:NSUTF8StringEncoding];
</span><span class='line'>   return [_sendUdp sendData:sendData toHost:USCSoundBoxSendHost port:9998 withTimeout:-1 tag:0];
</span><span class='line'>}
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure>


<hr />

<p>2.UDP接收</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)beginReceive
</span><span class='line'>{
</span><span class='line'>    NSError *error;
</span><span class='line'>    _receiveUdp = [[AsyncUdpSocket alloc] initWithDelegate:self];
</span><span class='line'>    [_receiveUdp enableBroadcast:YES error:&error];
</span><span class='line'>    [_receiveUdp bindToPort:9997 error:&error];
</span><span class='line'>    // 开始接受udp数据
</span><span class='line'>    [_receiveUdp receiveWithTimeout:-1 tag:0];
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>// 当收到udp数据包时就会调用，但是你经常会收到不是自己想要的数据包，这些数据包可能来着其他主机，你需要忽略掉这些，这个代理方法返回bool类型，如果返回NO,当收到其他数据包，就会继续调用这个代理方法。
</span><span class='line'>- (BOOL)onUdpSocket:(AsyncUdpSocket *)sock didReceiveData:(NSData *)data withTag:(long)tag fromHost:(NSString *)host port:(UInt16)port
</span><span class='line'>{
</span><span class='line'>    return NO;
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p>2.TCP 监听连接请求</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> // 开始监听 
</span><span class='line'> self.asyServer = [[AsyncSocket alloc]initWithDelegate:self];
</span><span class='line'> if([self.asyServer acceptOnPort:9997 error:&error]){
</span><span class='line'>       NSLog(@"开始监听端口。。。%d",USCSoundBoxClientPort);
</span><span class='line'> }else{
</span><span class='line'>     NSLog(@"errr=%@",error);
</span><span class='line'> }
</span><span class='line'>    
</span><span class='line'>
</span><span class='line'>// 建立连接，读取数据   
</span><span class='line'>- (void)onSocket:(AsyncSocket *)sock didAcceptNewSocket:(AsyncSocket *)newSocket
</span><span class='line'>{
</span><span class='line'>    NSLog(@"%@",[NSString stringWithFormat:@"建立与%@的连接",newSocket.connectedHost]);
</span><span class='line'>    self.acceptedSocket = newSocket;
</span><span class='line'>    [newSocket readDataWithTimeout:-1 tag:0];
</span><span class='line'>    newSocket.delegate = self;
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<h3>注意</h3>

<p>1.如果同时开启udp接收和tcp监听的话，tcp监听会失效。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[c++ oc 混编遇到的编译提示NSObjcRuntime error]]></title>
    <link href="http://githubdelegate.github.io/blog/2015/11/13/c-plus-plus-oc-hun-bian-yu-dao-de-bian-yi-ti-shi-nsobjcruntime-error/"/>
    <updated>2015-11-13T13:46:33+08:00</updated>
    <id>http://githubdelegate.github.io/blog/2015/11/13/c-plus-plus-oc-hun-bian-yu-dao-de-bian-yi-ti-shi-nsobjcruntime-error</id>
    <content type="html"><![CDATA[<p> OC 和C++混编时遇到编译错误会提示</p>

<blockquote><p><a href="http://blog.csdn.net/xuchaovip/article/details/22046115"> C++、Objective-c混编陷阱之–错误的头文件引用</a></p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CoreBluetooth 相关]]></title>
    <link href="http://githubdelegate.github.io/blog/2015/11/12/corebluetooth-xiang-guan/"/>
    <updated>2015-11-12T12:04:22+08:00</updated>
    <id>http://githubdelegate.github.io/blog/2015/11/12/corebluetooth-xiang-guan</id>
    <content type="html"><![CDATA[<ol>
<li></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在.mm文件中调用一个C函数]]></title>
    <link href="http://githubdelegate.github.io/blog/2015/11/06/crcjian-yan-fang-zai-viewcontroller/"/>
    <updated>2015-11-06T14:25:59+08:00</updated>
    <id>http://githubdelegate.github.io/blog/2015/11/06/crcjian-yan-fang-zai-viewcontroller</id>
    <content type="html"><![CDATA[<p>在项目中使用crc进行校验，在网上找到一份c的源码，但是放到项目当中一直编译失败，提示找不到对应的函数
一开始是认为是传递的参数不对，发现不是这个问题,<code>viewController.mm</code>中是用OC++编译的，导致编译不过，但是不明白原因，现在的解决办法是把这c函数放到<code>.m</code>的文件中编译就可以了。</p>

<hr />

<p>原因分析：原因是由于<code>ViewController.mm</code>是<code>.mm</code>后缀的，会按照OC++编译,所以在<code>ViewController.mm</code> 调用<code>int add(int a,int b)</code>函数，在链接阶段,就会去目标文件中去找<code>_add_int_int</code>这样的符号,不同的编译器可能会不同，但是C函数编译后生成的符号是<code>_int</code>，这就导致找不到对应的函数，编译失败,解决办法在C头文件中添加<code>extern "C"</code>，即可。详细解释，开下面的连接博客。</p>

<blockquote><p><a href="http://www.cnblogs.com/skynet/archive/2010/07/10/1774964.html">http://www.cnblogs.com/skynet/archive/2010/07/10/1774964.html</a>
<a href="http://www.jianshu.com/p/5d2eeeb93590">http://www.jianshu.com/p/5d2eeeb93590</a></p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Audiosession Category Qie Huan]]></title>
    <link href="http://githubdelegate.github.io/blog/2015/11/05/audiosession-category-qie-huan/"/>
    <updated>2015-11-05T00:00:00+08:00</updated>
    <id>http://githubdelegate.github.io/blog/2015/11/05/audiosession-category-qie-huan</id>
    <content type="html"><![CDATA[<p>在项目中遇到的问题是，使用<code>AudioQueue</code> 录音，进行语音识别，识别结束后，播报识别结果，但是录音还要继续，遇到的问题是播放的时候声音很小。原因是由于录音的时候设置了</p>

<pre><code>[[AVAudioSession sharedInstance] setCategory:AVAudioSessionCategoryPlayAndRecord error:nil];
</code></pre>

<p>这样设置之后，默认播放rout是听筒，而不是扬声器，声音就小了。
修改方法如下
方法一：</p>

<pre><code>[[AVAudioSession sharedInstance] setCategory:AVAudioSessionCategoryPlayAndRecord withOptions:AVAudioSessionCategoryOptionDefaultToSpeaker | AVAudioSessionCategoryOptionAllowBluetooth error:nil];
</code></pre>

<p>方法二：</p>

<pre><code>[session overrideOutputAudioPort:AVAudioSessionPortOverrideSpeaker error:&amp;error];
</code></pre>

<p>这两个方法的区别可以看这里<a href="https://developer.apple.com/library/ios/qa/qa1754/_index.html">AVAudioSessionCategoryOptionDefaultToSpeaker和AVAudioSessionPortOverrideSpeaker区别</a>，大概意思就是设置<code>AVAudioSessionPortOverrideSpeaker</code> 是临时性的，如果rout改变和audioSession被中断的话，这个设置就失效了，会返回到默认的设置。设置<code>AVAudioSessionCategoryOptionDefaultToSpeaker</code> 后，会一直生效。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS8 framework动态库遇到的问题]]></title>
    <link href="http://githubdelegate.github.io/blog/2015/09/08/ios8chuang-jian-frameworkyu-dao-de-wen-ti/"/>
    <updated>2015-09-08T14:32:29+08:00</updated>
    <id>http://githubdelegate.github.io/blog/2015/09/08/ios8chuang-jian-frameworkyu-dao-de-wen-ti</id>
    <content type="html"><![CDATA[<ol>
<li><p>编译显示<code>Include of non-modular header inside framework module</code> 错误</p>

<p>  修改<code>Build Setting</code> 中<code>Allow Non-modular Include InFramework Modules</code> 为YES.</p></li>
<li><p>在代码中引用头文件 <code>#import "***Kit.h"</code> 提示找不到</p>

<p> 这个时候要检查对应的framework target <code>Build Phases-&gt;Headers-&gt;Public</code> 是否包含对应的类。一般要提供给其他target使用的类的.h文件都应该放到Public中.</p></li>
</ol>

]]></content>
  </entry>
  
</feed>
