<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Alpine Blog]]></title>
  <link href="http://githubdelegate.github.io/atom.xml" rel="self"/>
  <link href="http://githubdelegate.github.io/"/>
  <updated>2015-12-17T15:51:13+08:00</updated>
  <id>http://githubdelegate.github.io/</id>
  <author>
    <name><![CDATA[zy]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[iOS 多线程间同步]]></title>
    <link href="http://githubdelegate.github.io/blog/2015/12/16/ios-duo-xian-cheng-jian-tong-bu/"/>
    <updated>2015-12-16T10:53:50+08:00</updated>
    <id>http://githubdelegate.github.io/blog/2015/12/16/ios-duo-xian-cheng-jian-tong-bu</id>
    <content type="html"><![CDATA[<h2>iOS 多线程同步</h2>

<h4>线程同步概念</h4>

<p>  同”字从字面上容易理解为一起动作其实不是，“同”字应是指协同、协助、互相配合。如进程、线程同步，可理解为进程或线程A和B一块配合，A执行到一定程度时要依靠B的某个结果，于是停下来，示意B运行；B依言执行，再将结果给A；A再继续操作。
    所谓同步，就是在发出一个功能调用时，在没有得到结果之前，该调用就不返回，同时其它线程也不能调用这个方法。按照这个定义，其实绝大多数函数都是同步调用（例如sin, isdigit等）。但是一般而言，我们在说同步、异步的时候，特指那些需要其他部件协作或者需要一定时间完成的任务。例如Window API函数SendMessage。该函数发送一个消息给某个窗口，在对方处理完消息之前，这个函数不返回。当对方处理完毕以后，该函数才把消息处理函数所返回的LRESULT值返回给调用者。
    在多线程编程里面，一些敏感数据不允许被多个线程同时访问，此时就使用同步访问技术，保证数据在任何时刻，最多有一个线程访问，以保证数据的完整性。
<code>我们可以通过</code>互斥锁(mutex)<code>，</code>条件变量(condition variable)<code>和</code>读写锁(reader-writer lock)<code>和</code>信号`来同步资源。</p>

<ul>
<li>互斥锁仅允许每次使用一个线程来执行特定的部分代码或者访问特定数据。</li>
<li>读写锁允许对受保护的共享资源进行并发读取和独占写入。要修改资源，线程必须首先获取互斥写锁。只有释放所有的读锁之后，才允许使用互斥写锁。</li>
<li>条件变量会一直阻塞线程，直到特定的条件为真。</li>
<li>计数信号量通常用来协调对资源的访问。使用计数，可以限制访问某个信号的线程数达到指定的计数时，信号将阻塞。</li>
</ul>


<h4>iOS多线程同步的办法</h4>

<h5><code>1.Atomic Operations</code></h5>

<p>原子操作是对简单的数据类型的最简单的同步方法。用原子操作的好处是不会阻塞正在竞争的线程，这比加锁好。</p>

<h5><code>2.Locks</code></h5>

<p>锁是最常用的同步工具。你可以用锁保护一段一次只允许一个线程执行的代码块。比如，一段操作一份关键数据的代码，或者用到一些一次只允许一个用户操作的资源。通过把一个锁放在这段代码两边，可以阻止其他线程修改。</p>

<ul>
<li><code>mutex lock</code></li>
</ul>


<pre><code class="`">
  - (void)viewDidLoad {
    [super viewDidLoad];

    self.test = 10;
    pthread_mutex_init(&amp;mutex, NULL);
    pthread_mutex_lock(&amp;mutex);
    self.test+=20;
    printf("test=%d",self.test);
}

- (IBAction)btn1Click:(id)sender {
    dispatch_async(dispatch_get_global_queue(0, 0), ^{
        pthread_mutex_lock(&amp;mutex); // 如果mutex没有释放会在这里等待
        self.test+=10;
        printf("test=%d\n",self.test);
        NSLog(@"current thread:%@",[NSThread currentThread]);
        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
            pthread_mutex_unlock(&amp;mutex);
        });
    });
}

    - (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event
    {
        pthread_mutex_unlock(&amp;mutex);
    }
</code></pre>

<p> 输出：</p>

<pre><code class="`">
test=30test=40
2015-12-16 18:07:27.297 threadSynTest[5908:374571] current thread:&lt;NSThread: 0x7b246080&gt;{number = 2, name = (null)}
test=50
2015-12-16 18:07:28.392 threadSynTest[5908:374574] current thread:&lt;NSThread: 0x7b2b6ce0&gt;{number = 3, name = (null)}
test=60
2015-12-16 18:07:29.415 threadSynTest[5908:374570] current thread:&lt;NSThread: 0x7b28a530&gt;{number = 4, name = (null)}
test=70
2015-12-16 18:07:30.423 threadSynTest[5908:374575] current thread:&lt;NSThread: 0x7b26c700&gt;{number = 5, name = (null)}
</code></pre>

<ul>
<li><code>NSLock</code></li>
</ul>


<p> 注意: <code>NSLock</code> 在<code>POSIX threads</code> 基础上实现的。当对一个NSLock 对象调用<code>unlock</code>方法，你必须要保证和给<code>NSLock</code>对象调用<code>lock</code>方法在同一个线程。在不同的线程里unlock会导致未知的错误。连续两次调用lock方法会导致死锁。如果要递归的加锁，用<code>NSRecursiveLock</code>。对一个未<code>lock</code> lock 调用<code>unlock</code>是不正确的，要修正。</p>

<p> <code>tryLock</code> :尝试加锁，并且会立即返回，成功返回YES，不会阻塞。
 <code>lock</code> 方法: 加锁，如果当前是在锁的状态，当前线程的会阻塞，直到加锁</p>

<ul>
<li><code>@synchronized</code></li>
</ul>


<p> <code>@synchronized</code> 指令可以非常方便的创建互斥锁，它会像其他互斥锁一样防止不同线程在同一时刻获得相同的锁。但是你并不需要创建<code>mutex lock</code>或<code>NSLock</code> 对象，相反你只需要简单用一个OC 对象作为一个lock token.
传递给@synchronized指令的对象是唯一的，用来区别被保护的代码块。如果你在不同的线程执行这个指令，并用不同的对象作为参数，每个线程会产生自己的锁，并且会继续运行，相互之间不会相互影响。然而，如果你传递相同的对象作为参数，一个线程会先获得锁，另外一个会阻塞等待到第一个执行完成。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>- (IBAction)synchrinized:(id)sender {
</span><span class='line'>    
</span><span class='line'>    dispatch_async(dispatch_get_global_queue(0, 0), ^{
</span><span class='line'>        @synchronized(self) {
</span><span class='line'>            [self changeValue];
</span><span class='line'>            [NSThread sleepUntilDate:[NSDate dateWithTimeIntervalSinceNow:3]];
</span><span class='line'>        }
</span><span class='line'>        
</span><span class='line'>        dispatch_async(dispatch_get_main_queue(), ^{
</span><span class='line'>            @synchronized(self) {
</span><span class='line'>                [self changeValue];
</span><span class='line'>            }
</span><span class='line'>        });
</span><span class='line'>    });
</span><span class='line'>    
</span><span class='line'>    @synchronized(self) {
</span><span class='line'>        [self changeValue];
</span><span class='line'>        [NSThread sleepUntilDate:[NSDate dateWithTimeIntervalSinceNow:3]];
</span><span class='line'>    }
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>2015-12-16 19:51:18.829 threadSynTest[6717:497526] test==20---current thread:&lt;NSThread: 0x7ba3af80&gt;{number = 1, name = main}
</span><span class='line'>2015-12-16 19:51:21.831 threadSynTest[6717:497574] test==30---current thread:&lt;NSThread: 0x7b84d860&gt;{number = 2, name = (null)}
</span><span class='line'>2015-12-16 19:51:24.837 threadSynTest[6717:497526] test==40---current thread:&lt;NSThread: 0x7ba3af80&gt;{number = 1, name = main}
</span></code></pre></td></tr></table></div></figure>


<ul>
<li><code>NSRecursiveLock</code></li>
</ul>


<p> <code>NSRecursiveLock</code> 定义一种可以被同一个线程多次加锁而且不会引起死锁.递归锁会记录当前被成功加了多少次锁，只有加锁和解锁次数一样，平衡时，这个锁最终才被释放，其他线程才能获得这个锁。递归锁通常用在递归函数内部防止递归操作阻塞线程。当然你也可以用在非递归的场合。</p>

<pre><code class="`">
- (void)recursiveFun:(int)count
{
    [self.recursiveLock lock];
    [self changeValue];
    if (count != 0) {
        count--;
        [self recursiveFun:count];
    }

    [self.recursiveLock unlock];
}
</code></pre>

<ul>
<li><code>NSConditionLock</code></li>
</ul>


<p><code>NSConditionLock</code> 定义了一个可以通过特殊的值来锁和解锁的互斥锁。不要和<code>Condition</code>搞混，虽然这种方式和条件很像，但是实现完全不同。
特别是当线程之间需要需要按照一个特殊的顺序执行任务的时候，你应该使用<code>NSConditionLock</code>,比如一个线程生产数据，另一个消费数据。当生产者正在执行的时候，消费者用条件请求锁。当生产者完成后，解锁并设置条件，唤醒消费线程，去消费数据。
<code>NSConditionLock</code>的加锁和解锁方法可以各种组合。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>- (void)sendSharedData{
</span><span class='line'>    [self.conditionLock lock];
</span><span class='line'>    [self.sharedArray addObject:@1];
</span><span class='line'>    NSLog(@"添加数据 thread:%@",[NSThread currentThread]);
</span><span class='line'>    [self.conditionLock unlockWithCondition:1];
</span><span class='line'>    [NSThread sleepUntilDate:[NSDate dateWithTimeIntervalSinceNow:0.3]];
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>- (IBAction)conditionlock:(id)sender {
</span><span class='line'>    dispatch_async(dispatch_get_global_queue(0, 0), ^{
</span><span class='line'>        while (1) {
</span><span class='line'>            [self.conditionLock lockWhenCondition:1];
</span><span class='line'>            [self.sharedArray removeObjectAtIndex:0];
</span><span class='line'>            NSLog(@"消耗一个数据 thread:%@",[NSThread currentThread]);
</span><span class='line'>            BOOL isEmpty = self.sharedArray.count == 0 ? YES : NO;
</span><span class='line'>            [self.conditionLock unlockWithCondition:(isEmpty ? 0 : 1)];
</span><span class='line'>            [NSThread sleepUntilDate:[NSDate dateWithTimeIntervalSinceNow:2]];
</span><span class='line'>        }
</span><span class='line'>    });
</span><span class='line'>    
</span><span class='line'>    dispatch_async(dispatch_get_global_queue(0, 0), ^{
</span><span class='line'>        NSTimer *timer = [NSTimer scheduledTimerWithTimeInterval:0.5 target:self selector:@selector(sendSharedData) userInfo:nil repeats:YES];
</span><span class='line'>        [[NSRunLoop currentRunLoop] run];
</span><span class='line'>    });
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure>


<h5><code>3.Conditions</code></h5>

<pre><code>条件是另一种信号量，当满足某个条件的时候能允许其他线程运行。条件信号量主要用来表示某个资源可用个数，和保证线程安装固定的顺序运行。当一个线程需要某个condition的时候，会一直阻塞等待，直到只有当其他线程改变了条件信号量。互斥和条件信号量之间的区别是用条件信号量允许多个线程同时获得条件，运行。条件信号量就像门卫一样，根据资源的多少，决定让不同的线程可以进入。
</code></pre>

<h3>使用<code>Conditions</code></h3>

<p>条件是一种特殊类型的锁，它可以用来同步各个操作   顺序。条件和同步锁之间的区别很微妙。一个线程等待一个条件会阻塞，直到另外一个线程明确的发出条件信号。</p>

<ul>
<li><code>POSIX Conditions</code>
  <code>POSIX</code> 线程条件锁要求同时使用条件和互斥。运行时互斥锁约束条件，等待信号的线程使用同样的互斥和条件变量。</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (IBAction)distributedlock:(id)sender {
</span><span class='line'>
</span><span class='line'>    dispatch_async(dispatch_get_global_queue(0, 0), ^{
</span><span class='line'>        [self waitOnConditionfun];
</span><span class='line'>    });
</span><span class='line'>
</span><span class='line'>    dispatch_async(dispatch_get_global_queue(0, 0), ^{
</span><span class='line'>        [self signalThreadCondition];
</span><span class='line'>    });
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>- (void)waitOnConditionfun{
</span><span class='line'>    
</span><span class='line'>    // mutex 如果等待线程先获得mutex，加锁。那signal如何获得锁，又如何加锁呢。哦如果不成功，直接就解锁
</span><span class='line'>    pthread_mutex_lock(&mutex);
</span><span class='line'>    while (ready_to_go) {
</span><span class='line'>        NSLog(@"wait--thread:%@",[NSThread currentThread]);
</span><span class='line'>        pthread_cond_wait(&condition, &mutex);
</span><span class='line'>    }
</span><span class='line'>    ready_to_go = false;
</span><span class='line'>    pthread_mutex_unlock(&mutex);
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>- (void)signalThreadCondition{
</span><span class='line'>
</span><span class='line'>    // At this point, there should be work for the other thread to do.
</span><span class='line'>    pthread_mutex_lock(&mutex);
</span><span class='line'>    ready_to_go = true;
</span><span class='line'>    // Signal the other thread to begin work.
</span><span class='line'>    pthread_cond_signal(&condition);
</span><span class='line'>    NSLog(@"signal--thread:%@",[NSThread currentThread]);
</span><span class='line'>    pthread_mutex_unlock(&mutex);
</span><span class='line'>}
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>NSCondition</li>
</ul>


<p><code>NSCondition</code>提供了和<code>POSIX condition</code>相同的功能，但是把请求锁和条件封装成一个对象，结果就是你只用它就可以实现互斥加锁和条件等待。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>- (IBAction)nscondition:(id)sender {
</span><span class='line'>    
</span><span class='line'>    dispatch_async(dispatch_get_global_queue(0, 0), ^{
</span><span class='line'>        while (1) {
</span><span class='line'>            [self.condition lock];
</span><span class='line'>            while (timeToWork &lt;= 0) {
</span><span class='line'>                [self.condition wait];
</span><span class='line'>            }
</span><span class='line'>            timeToWork--;
</span><span class='line'>            NSLog(@"消费数据--thread:%@",[NSThread currentThread]);
</span><span class='line'>            [self.condition unlock];
</span><span class='line'>        }
</span><span class='line'>    });
</span><span class='line'>
</span><span class='line'>    dispatch_async(dispatch_get_global_queue(0, 0), ^{
</span><span class='line'>        while (1) {
</span><span class='line'>            [self.condition lock];
</span><span class='line'>            timeToWork++;
</span><span class='line'>            NSLog(@"添加数据--thread:%@",[NSThread currentThread]);
</span><span class='line'>            [self.condition signal];
</span><span class='line'>            [self.condition unlock];
</span><span class='line'>            [NSThread sleepUntilDate:[NSDate dateWithTimeIntervalSinceNow:1]];
</span><span class='line'>        }
</span><span class='line'>    });
</span><span class='line'>}
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure>


<h4>线程安全设计技巧</h4>

<ul>
<li>避免同步</li>
</ul>


<p>同步工具不是万灵药，锁用的太多会导致性能低于没有使用同步的程序。寻找线程安全和性能的平衡是需要经验。实现同步最好的方法是减小线程间的交互，让同步任务相互独立。如果每个任务操作自己私有数据，就不需要使用锁来保护数据。如果不同的任务共享一块数据，你可以尝试把数据分割，或复制一份数据，虽然这也消耗性能，你可以再决定前权衡一下。</p>

<ul>
<li>理解同步的限制</li>
</ul>


<p>同步工具只有被所有的线程一直使用才能最有效。如果创建一个互斥锁用来限制对某个资源的访问，你的所以线程必须请求相同的互斥变量才能操作这个数据。如果没达到这个效果，是一个程序员的错误！！！！</p>

<ul>
<li>正确编码的风险</li>
</ul>


<p>当使用锁的时候，你必须非常的小心的实现你的代码。因为锁可能看起来很好的实现了，但是还是存在安全问题。看下面的例子，</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSLock* arrayLock = GetArrayLock();
</span><span class='line'>NSMutableArray* myArray = GetSharedArray();
</span><span class='line'>id anObject;
</span><span class='line'> 
</span><span class='line'>[arrayLock lock];
</span><span class='line'>anObject = [myArray objectAtIndex:0];
</span><span class='line'>[arrayLock unlock];
</span><span class='line'> 
</span><span class='line'>[anObject doSomething];
</span></code></pre></td></tr></table></div></figure>


<p>上面的代码，因为array 是可变的，这个lock会一直保护这个array，知道你得到<code>anobject</code>,而且因为anobject 是不可变的，所以<code>[anObject doSomething];</code>不需要锁的保护。但是这段代码有个问题，就是当获得了<code>anb=object</code>后，但是还没执行<code>[anObject doSomething];</code>之前，另外一个线程获得了lock并且把<code>myarray</code>里面的元素全部删掉了，iOS没有内存垃圾机制的，所以<code>anobject</code>指向的对象会被释放，<code>anobject</code>指针会指向一个非法的地址，解决这个问题，你可能会把<code>[anObject doSomething];</code>也放在锁里面，但是这会消耗很长时间，导致其他线程会长时间的等待。正确的做法应该是，保证<code>anobject</code>不会被释放.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>NSLock* arrayLock = GetArrayLock();
</span><span class='line'>NSMutableArray* myArray = GetSharedArray();
</span><span class='line'>id anObject;
</span><span class='line'> 
</span><span class='line'>[arrayLock lock];
</span><span class='line'>anObject = [myArray objectAtIndex:0];
</span><span class='line'>[anObject retain];
</span><span class='line'>[arrayLock unlock];
</span><span class='line'> 
</span><span class='line'>[anObject doSomething];
</span><span class='line'>[anObject release];
</span></code></pre></td></tr></table></div></figure>


<ul>
<li><p>小心死锁活锁</p>

<pre><code>  任何时候一个线程一次想要获取多于一个锁，都有死锁的可能。死锁是两个线程分别获得一个锁后，又想去得到另外一个线程的锁。结果就是每个线程都会一直阻塞下去。以下是对死锁和活锁的形象描述。 现有个过道，两个人宽，两侧迎面走来两个人A和B。 死锁的情况： A和B都不是讲礼貌的人，都不愿给别人让路，所以A和B都在等对方让路，导致谁也过不去。 活锁的情况： A和B都是很讲礼貌的人，都主动给别人让路。A往左移，同时B往右移；A往右移，同时B往左移。 A和B在移动的时候，同时挡住对方，导致谁也过不去
</code></pre></li>
<li><p>正确的使用验证变量</p>

<pre><code>  如果你已经使用了互斥锁保护一段代码，就不要再使用验证关键字去保护代码中重要变量。互斥包括一个内存栅栏去确保读取和写入操作的次序。添加一个验证变量会导致强制读取值每次，降低性能。如果一个互斥锁足够的话，就不要再使用了。
</code></pre></li>
</ul>


<h4>不同方法使用的场合，优缺点</h4>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[swift 中单例的实现]]></title>
    <link href="http://githubdelegate.github.io/blog/2015/12/14/swift-zhong-dan-li-de-shi-xian/"/>
    <updated>2015-12-14T18:54:44+08:00</updated>
    <id>http://githubdelegate.github.io/blog/2015/12/14/swift-zhong-dan-li-de-shi-xian</id>
    <content type="html"><![CDATA[<h1>Swift单例</h1>

<p>Use the <strong>class constant</strong> approach if you are using Swift 1.2 or above and the <strong>nested struct</strong> approach if you need to support earlier versions._</p>

<p>An exploration of the Singleton pattern in Swift. All approaches below support lazy initialization and thread safety.</p>

<p>Issues and pull requests welcome.</p>

<h3>Approach A: Class constant</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class SingletonA {
</span><span class='line'>    
</span><span class='line'>    static let sharedInstance = SingletonA()
</span><span class='line'>    
</span><span class='line'>    init() {
</span><span class='line'>        println("AAA");
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>This approach supports lazy initialization because Swift lazily initializes class constants (and variables), and is thread safe by the definition of <code>let</code>.</p>

<p>Class constants were introduced in Swift 1.2. If you need to support an earlier version of Swift, use the nested struct approach below or a global constant.</p>

<h3>Approach B: Nested struct</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class SingletonB {
</span><span class='line'>    
</span><span class='line'>    class var sharedInstance: SingletonB {
</span><span class='line'>        struct Static {
</span><span class='line'>            static let instance: SingletonB = SingletonB()
</span><span class='line'>        }
</span><span class='line'>        return Static.instance
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>在类变量里嵌套一个 <code>Static</code> 结构体。
<code>Static</code> 封装了一个静态的常量，通过 static 定义意味着这个属性只存在一个，注意 Swift 中 static 的变量是延时加载的，意味着 Instance 直到需要的时候才会被创建。同时再注意一下，因为它是一个常量，所以一旦创建之后不会再创建第二次。这些就是单例模式的核心所在：一旦初始化完成，当前类存在一个实例对象，初始化方法就不会再被调用。</p>

<p>Here we are using the static constant of a nested struct as a class constant. This is a workaround for the lack of static class constants in Swift 1.1 and earlier, and still works as a workaround for the lack of static constants and variables in functions.</p>

<h3>Approach C: dispatch_once</h3>

<p>The traditional Objective-C approach ported to Swift.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class SingletonC {
</span><span class='line'>    
</span><span class='line'>    class var sharedInstance: SingletonC {
</span><span class='line'>        struct Static {
</span><span class='line'>            static var onceToken: dispatch_once_t = 0
</span><span class='line'>            static var instance: SingletonC? = nil
</span><span class='line'>        }
</span><span class='line'>        dispatch_once(&Static.onceToken) {
</span><span class='line'>            Static.instance = SingletonC()
</span><span class='line'>        }
</span><span class='line'>        return Static.instance!
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>I&rsquo;m fairly certain there&rsquo;s no advantage over the nested struct approach but I&rsquo;m including it anyway as I find the differences in syntax interesting.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[转：iOS中的正则表达式]]></title>
    <link href="http://githubdelegate.github.io/blog/2015/12/03/zhuan-:ioszhong-de-zheng-ze-biao-da-shi/"/>
    <updated>2015-12-03T10:15:22+08:00</updated>
    <id>http://githubdelegate.github.io/blog/2015/12/03/zhuan-:ioszhong-de-zheng-ze-biao-da-shi</id>
    <content type="html"><![CDATA[<h1>转自lady-奕奕：<a href="http://my.oschina.net/u/1245365/blog/376517">正则表达式在iOS中的运用</a></h1>

<h4>一、什么是正则表达式</h4>

<pre><code>  正则表达式，又称正规表示法，是对字符串操作的一种逻辑公式。正则表达式可以检测给定的字符串是否符合我们定义的逻辑，也可以从字符串中获取我们想要的特定部分。它可以迅速地用极简单的方式达到字符串的复杂控制。
</code></pre>

<h4>二、正则表达式的语法</h4>

<p>看一个过滤纯数字的例子</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (BOOL)validateNumber:(NSString *) textString
</span><span class='line'>{
</span><span class='line'>    NSString* number=@"^[0-9]+$";
</span><span class='line'>    NSPredicate *numberPre = [NSPredicate predicateWithFormat:@"SELF MATCHES %@",number];
</span><span class='line'>    return [numberPre evaluateWithObject:textString];
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>其中下述语句就是一个正则表达式</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@"^[0-9]+$"
</span></code></pre></td></tr></table></div></figure>


<p>它代表了字符串中只能包含>=1个0-9的数字，语法是不是有一些怪异？</p>

<pre><code> 下面我们先撇开iOS中的正则表达式的语法，用通俗的正则表达式语法来为介绍一下。（iOS语法与通俗的正则表达式语法相同，不同在于对转义字符的处理上(语言类的都相同)）
</code></pre>

<p>语法：</p>

<pre><code>首先，符号'^'和'$'。他们分别指出一个字符串的开始和结束。eg：
"^one"：表示所有以"one"开始的字符串（"one cat"，"one123"，·····）；
类似于:- (BOOL)hasPrefix:(NSString *)aString;
"a dog$"：表示所以以"a dog"结尾的字符串（"it is a dog"，·····）；
类似于:- (BOOL)hasSuffix:(NSString *)aString;
"^apple$"：表示开始和结尾都是"apple"的字符串，这个是唯一的~；
"banana"：表示任何包含"banana"的字符串。
类似于 iOS8的新方法- (BOOL)containsString:(NSString *)aString,搜索子串用的。
'*'，'+'和'?'这三个符号，表示一个或N个字符重复出现的次数。它们分别表示“没有或
更多”（[0,+∞]取整），“一次或更多”（[1,+∞]取整），“没有或一次”（[0,1]取整）。下面是几个例子：
"ab*"：表示一个字符串有一个a后面跟着零个或若干个b（"a", "ab", "abbb",……）；
"ab+"：表示一个字符串有一个a后面跟着至少一个b或者更多（ "ab", "abbb",……）；
"ab?"：表示一个字符串有一个a后面跟着零个或者一个b（ "a", "ab"）；
"a?b+$"：表示字符串以零个或一个a跟着一个或几个b结尾（ "b", "ab","bb","abb",……）。
可以用大括号括起来（{}），表示一个重复的具体范围。例如
"ab{4}"：表示一个字符串有一个a跟着4个b（"abbbb"）；
"ab{1,}"：表示一个字符串有一个a跟着至少1个b（"ab","abb","abbb",……)；
"ab{3,4}"：表示一个字符串有一个a跟着3到4个b（"abbb","abbbb")。
那么，“*”可以用{0，}表示，“+”可以用{1，}表示，“?”可以用{0，1}表示
注意：可以没有上限，但是不能没有下限！例如“ab{,5}”是错误的写法
" | "表示“或”操作：
"a|b"：表示一个字符串里有"a"或者"b"；
"(a|bcd)ef"：表示"aef"或"bcdef"；
"(a|b)*c"：表示一串"a""b"混合的字符串后面跟一个"c"；

方括号"[ ]"表示在括号内的众多字符中，选择1-N个括号内的符合语法的字符作为结果，例如
"[ab]"：表示一个字符串有一个"a"或"b"（相当于"a|b"）；
"[a-d]"：表示一个字符串包含小写的'a'到'd'中的一个（相当于"a|b|c|d"或者"[abcd]"）；
"^[a-zA-Z]"：表示一个以字母开头的字符串；
"[0-9]a"：表示a前有一位的数字；
"[a-zA-Z0-9]$"：表示一个字符串以一个字母或数字结束。
"."匹配除“\r\n”之外的任何单个字符：
"a.[a-z]"：表示一个字符串有一个"a"后面跟着一个任意字符和一个小写字母；
"^.{5}$"：表示任意1个长度为5的字符串；

"\num" 其中num是一个正整数。表示"\num"之前的字符出现相同的个数，例如
"(.)\1"：表示两个连续的相同字符。
"10\{1,2\}” : 表示数字1后面跟着1或者2个0 ("10","100")。
" 0\{3,\} " 表示数字为至少3个连续的0 （“000”，“0000”，······）。
在方括号里用'^'表示不希望出现的字符，'^'应在方括号里的第一位。
"@[^a-zA-Z]@"表示两个"@"中不应该出现字母）。

常用的还有：
" \d "匹配一个数字字符。等价于[0-9]。
“ \D”匹配一个非数字字符。等价于[^0-9]。
" \w "匹配包括下划线的任何单词字符。等价于“[A-Za-z0-9_]”。
“ \W ”匹配任何非单词字符。等价于“[^A-Za-z0-9_]”。
</code></pre>

<p><strong>iOS中书写正则表达式，碰到转义字符，多加一个“\”,例如：全数字字符：@&ldquo;^\d+$&rdquo;</strong></p>

<h4>三、iOS中正则表达式</h4>

<p>1.正则表达式与NSPredicate连用，eg：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (BOOL)validateNumber:(NSString *) textString
</span><span class='line'>{
</span><span class='line'>    NSString* number=@"^[0-9]+$";
</span><span class='line'>    NSPredicate *numberPre = [NSPredicate predicateWithFormat:@"SELF MATCHES %@",number];
</span><span class='line'>    return [numberPre evaluateWithObject:textString];
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>2.NSString方法</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (NSRange)rangeOfString:(NSString *)aString options:(NSStringCompareOptions)mask;
</span><span class='line'>NSString *searchText = @"rangeOfString";
</span><span class='line'>NSRange range = [searchText rangeOfString:@"^[0-9]+$" options:NSRegularExpressionSearch];
</span><span class='line'>if (range.location != NSNotFound) {
</span><span class='line'>   NSLog(@"range ：%@", [searchText substringWithRange:range]);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>3.正则表达式类（NSRegularExpression）</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSString *searchText = @"you want to match";    
</span><span class='line'>NSError *error = NULL;
</span><span class='line'>NSRegularExpression *regex = [NSRegularExpression regularExpressionWithPattern:@"^[0-9]+$" options:NSRegularExpressionCaseInsensitive error:&error];
</span><span class='line'>NSTextCheckingResult *result = [regex firstMatchInString:searchText options:0 range:NSMakeRange(0, [searchText length])];
</span><span class='line'>if (result) {
</span><span class='line'>   NSLog(@"%@", [searchText substringWithRange:result.range]);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h4>四、常用的正则表达式</h4>

<pre><code>以下红色字符串是常用的正则表达式（以下正则表达式来自百度百科） 


1.验证用户名和密码："^[a-zA-Z]\w{5,15}$" 
2.验证电话号码：（"^(\\d{3,4}-)\\d{7,8}$"）
eg：021-68686868  0511-6868686；
3.验证手机号码："^1[3|4|5|7|8][0-9]\\d{8}$"；
4.验证身份证号（15位或18位数字）："\\d{14}[[0-9],0-9xX]"；
5.验证Email地址：("^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\.\\w+([-.]\\w+)*$")；
6.只能输入由数字和26个英文字母组成的字符串：("^[A-Za-z0-9]+$") ;
7.整数或者小数：^[0-9]+([.]{0,1}[0-9]+){0,1}$
8.只能输入数字："^[0-9]*$"。
9.只能输入n位的数字："^\\d{n}$"。
10.只能输入至少n位的数字："^\\d{n,}$"。
11.只能输入m~n位的数字："^\\d{m,n}$"。
12.只能输入零和非零开头的数字："^(0|[1-9][0-9]*)$"。
13.只能输入有两位小数的正实数："^[0-9]+(.[0-9]{2})?$"。
14.只能输入有1~3位小数的正实数："^[0-9]+(\.[0-9]{1,3})?$"。
15.只能输入非零的正整数："^\+?[1-9][0-9]*$"。
16.只能输入非零的负整数："^\-[1-9][]0-9"*$。
17.只能输入长度为3的字符："^.{3}$"。
18.只能输入由26个英文字母组成的字符串："^[A-Za-z]+$"。
19.只能输入由26个大写英文字母组成的字符串："^[A-Z]+$"。
20.只能输入由26个小写英文字母组成的字符串："^[a-z]+$"。
21.验证是否含有^%&amp;',;=?$\"等字符："[^%&amp;',;=?$\x22]+"。
22.只能输入汉字："^[\u4e00-\u9fa5]{0,}$"。
23.验证URL："^http://([\\w-]+\.)+[\\w-]+(/[\\w-./?%&amp;=]*)?$"。
24.验证一年的12个月："^(0?[1-9]|1[0-2])$"正确格式为："01"～"09"和"10"～"12"。
25.验证一个月的31天："^((0?[1-9])|((1|2)[0-9])|30|31)$"正确格式 为；"01"～"09"、"10"～"29"和“30”~“31”。
26.获取日期正则表达式：\\d{4}[年|\-|\.]\\d{\1-\12}[月|\-|\.]\\d{\1-\31}日?
评注：可用来匹配大多数年月日信息。
27.匹配双字节字符(包括汉字在内)：[^\x00-\xff]
评注：可以用来计算字符串的长度（一个双字节字符长度计2，ASCII字符计1）
28.匹配空白行的正则表达式：\n\s*\r
评注：可以用来删除空白行
29.匹配HTML标记的正则表达式：&lt;(\S*?)[^&gt;]*&gt;.*?&lt;/&gt;|&lt;.*? /&gt;
评注：网上流传的版本太糟糕，上面这个也仅仅能匹配部分，对于复杂的嵌套标记依旧无能为力
30.匹配首尾空白字符的正则表达式：^\s*|\s*$
评注：可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式
31.匹配网址URL的正则表达式：[a-zA-z]+://[^\s]*
评注：网上流传的版本功能很有限，上面这个基本可以满足需求
32.匹配帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$
评注：表单验证时很实用
33.匹配腾讯QQ号：[1-9][0-9]\{4,\}
评注：腾讯QQ号从10 000 开始
34.匹配中国邮政编码：[1-9]\\d{5}(?!\d)
评注：中国邮政编码为6位数字
35.匹配ip地址：((2[0-4]\\d|25[0-5]|[01]?\\d\\d?)\.){3}(2[0-4]\\d|25[0-5]|[01]?\\d\\d?)。
</code></pre>

<h4>五、正则表达式练习网站</h4>

<ol>
<li><a href="http://regexper.com/">Regexper</a> 图形化的显示正则表达式</li>
<li><a href="http://tool.oschina.net/regex">在线正则表达式测试</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ios-jenkins构建]]></title>
    <link href="http://githubdelegate.github.io/blog/2015/11/24/ios-jenkinsgou-jian/"/>
    <updated>2015-11-24T10:12:57+08:00</updated>
    <id>http://githubdelegate.github.io/blog/2015/11/24/ios-jenkinsgou-jian</id>
    <content type="html"><![CDATA[<h2>iOS SDK自动化构建</h2>

<ol>
<li>C库代码引用
 C库文件太多，而且里面有很多文件不能引用到项目中，不然会导致编译失败，以前使用的办法是先全部引入再删除部分文件，太麻烦了，想通过修改配置文件的方式</li>
<li>Framework的引用</li>
<li>Configure文件 设置buildSetting</li>
<li>自动测试批量测试测试报告生成</li>
<li>MAC 小软件自动生成SDK Demo</li>
<li>jenkins的自动构建</li>
<li>jenkins 自动打包生成ipa上传测试</li>
<li>自动生成Xcode工程，</li>
</ol>


<hr />

<p> # 测试项目直接包含SDK工程</p>

<ol>
<li><code>.mm</code></li>
<li>引用<code>Framework</code> 这个可以后面通过修改xc配置文件完成</li>
<li><code>User Search Header</code> 这个可以通过<code>config</code> 配置文件完成。</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS UDP发广播,接收,TCP监听]]></title>
    <link href="http://githubdelegate.github.io/blog/2015/11/18/iosudpfa-yan-bo-hou-jian-li-tcplian-jie/"/>
    <updated>2015-11-18T11:30:45+08:00</updated>
    <id>http://githubdelegate.github.io/blog/2015/11/18/iosudpfa-yan-bo-hou-jian-li-tcplian-jie</id>
    <content type="html"><![CDATA[<p>iOS 手机端先发送UDP广播，硬件设备端收到后，建立TCP连接，然后手机端读取硬件设备发送的信息。</p>

<hr />

<p>1.UDP广播</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>- (void)viewDidAppear:(BOOL)animated
</span><span class='line'>{
</span><span class='line'>    [super viewDidAppear:animated];
</span><span class='line'>    
</span><span class='line'>     // 1.开始发送udp
</span><span class='line'>    [self setupUdpClient];
</span><span class='line'>    
</span><span class='line'>    // 2.开启定时器，每个一秒发送一次
</span><span class='line'>    self.sendTimer = [NSTimer scheduledTimerWithTimeInterval:1 target:self selector:@selector(p_sendUdp) userInfo:nil repeats:YES];
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>- (void)setupUdpClient
</span><span class='line'>{
</span><span class='line'>    NSError *error;
</span><span class='line'>    _sendUdp = [[AsyncUdpSocket alloc] initWithDelegate:self];
</span><span class='line'>    [_sendUdp enableBroadcast:YES error:&error]; // 开启广播
</span><span class='line'>    if (![self checkError:error]) {
</span><span class='line'>        return;
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    [_sendUdp bindToPort:9997 error:&error]; // 绑定端口
</span><span class='line'>    if (![self checkError:error]) {
</span><span class='line'>        return;
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>- (BOOL)p_sendUdp
</span><span class='line'>{
</span><span class='line'>    NSString *sendStr = [NSString stringWithFormat:@"{\"ip\":\"\%@\"}",[Helper getIPAddress]]; // 发送本机IP地址
</span><span class='line'>    NSData *sendData = [sendStr dataUsingEncoding:NSUTF8StringEncoding];
</span><span class='line'>   return [_sendUdp sendData:sendData toHost:USCSoundBoxSendHost port:9998 withTimeout:-1 tag:0];
</span><span class='line'>}
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure>


<hr />

<p>2.UDP接收</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)beginReceive
</span><span class='line'>{
</span><span class='line'>    NSError *error;
</span><span class='line'>    _receiveUdp = [[AsyncUdpSocket alloc] initWithDelegate:self];
</span><span class='line'>    [_receiveUdp enableBroadcast:YES error:&error];
</span><span class='line'>    [_receiveUdp bindToPort:9997 error:&error];
</span><span class='line'>    // 开始接受udp数据
</span><span class='line'>    [_receiveUdp receiveWithTimeout:-1 tag:0];
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>// 当收到udp数据包时就会调用，但是你经常会收到不是自己想要的数据包，这些数据包可能来着其他主机，你需要忽略掉这些，这个代理方法返回bool类型，如果返回NO,当收到其他数据包，就会继续调用这个代理方法。
</span><span class='line'>- (BOOL)onUdpSocket:(AsyncUdpSocket *)sock didReceiveData:(NSData *)data withTag:(long)tag fromHost:(NSString *)host port:(UInt16)port
</span><span class='line'>{
</span><span class='line'>    return NO;
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p>2.TCP 监听连接请求</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> // 开始监听 
</span><span class='line'> self.asyServer = [[AsyncSocket alloc]initWithDelegate:self];
</span><span class='line'> if([self.asyServer acceptOnPort:9997 error:&error]){
</span><span class='line'>       NSLog(@"开始监听端口。。。%d",USCSoundBoxClientPort);
</span><span class='line'> }else{
</span><span class='line'>     NSLog(@"errr=%@",error);
</span><span class='line'> }
</span><span class='line'>    
</span><span class='line'>
</span><span class='line'>// 建立连接，读取数据   
</span><span class='line'>- (void)onSocket:(AsyncSocket *)sock didAcceptNewSocket:(AsyncSocket *)newSocket
</span><span class='line'>{
</span><span class='line'>    NSLog(@"%@",[NSString stringWithFormat:@"建立与%@的连接",newSocket.connectedHost]);
</span><span class='line'>    self.acceptedSocket = newSocket;
</span><span class='line'>    [newSocket readDataWithTimeout:-1 tag:0];
</span><span class='line'>    newSocket.delegate = self;
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<h3>注意</h3>

<p>1.如果同时开启udp接收和tcp监听的话，tcp监听会失效。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[c++ oc 混编遇到的编译提示NSObjcRuntime error]]></title>
    <link href="http://githubdelegate.github.io/blog/2015/11/13/c-plus-plus-oc-hun-bian-yu-dao-de-bian-yi-ti-shi-nsobjcruntime-error/"/>
    <updated>2015-11-13T13:46:33+08:00</updated>
    <id>http://githubdelegate.github.io/blog/2015/11/13/c-plus-plus-oc-hun-bian-yu-dao-de-bian-yi-ti-shi-nsobjcruntime-error</id>
    <content type="html"><![CDATA[<p> OC 和C++混编时遇到编译错误会提示</p>

<blockquote><p><a href="http://blog.csdn.net/xuchaovip/article/details/22046115"> C++、Objective-c混编陷阱之–错误的头文件引用</a></p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CoreBluetooth 相关]]></title>
    <link href="http://githubdelegate.github.io/blog/2015/11/12/corebluetooth-xiang-guan/"/>
    <updated>2015-11-12T12:04:22+08:00</updated>
    <id>http://githubdelegate.github.io/blog/2015/11/12/corebluetooth-xiang-guan</id>
    <content type="html"><![CDATA[<ol>
<li></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在.mm文件中调用一个C函数]]></title>
    <link href="http://githubdelegate.github.io/blog/2015/11/06/crcjian-yan-fang-zai-viewcontroller/"/>
    <updated>2015-11-06T14:25:59+08:00</updated>
    <id>http://githubdelegate.github.io/blog/2015/11/06/crcjian-yan-fang-zai-viewcontroller</id>
    <content type="html"><![CDATA[<p>在项目中使用crc进行校验，在网上找到一份c的源码，但是放到项目当中一直编译失败，提示找不到对应的函数
一开始是认为是传递的参数不对，发现不是这个问题,<code>viewController.mm</code>中是用OC++编译的，导致编译不过，但是不明白原因，现在的解决办法是把这c函数放到<code>.m</code>的文件中编译就可以了。</p>

<hr />

<p>原因分析：原因是由于<code>ViewController.mm</code>是<code>.mm</code>后缀的，会按照OC++编译,所以在<code>ViewController.mm</code> 调用<code>int add(int a,int b)</code>函数，在链接阶段,就会去目标文件中去找<code>_add_int_int</code>这样的符号,不同的编译器可能会不同，但是C函数编译后生成的符号是<code>_int</code>，这就导致找不到对应的函数，编译失败,解决办法在C头文件中添加<code>extern "C"</code>，即可。详细解释，开下面的连接博客。</p>

<blockquote><p><a href="http://www.cnblogs.com/skynet/archive/2010/07/10/1774964.html">http://www.cnblogs.com/skynet/archive/2010/07/10/1774964.html</a>
<a href="http://www.jianshu.com/p/5d2eeeb93590">http://www.jianshu.com/p/5d2eeeb93590</a></p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Audiosession Category Qie Huan]]></title>
    <link href="http://githubdelegate.github.io/blog/2015/11/05/audiosession-category-qie-huan/"/>
    <updated>2015-11-05T00:00:00+08:00</updated>
    <id>http://githubdelegate.github.io/blog/2015/11/05/audiosession-category-qie-huan</id>
    <content type="html"><![CDATA[<p>在项目中遇到的问题是，使用<code>AudioQueue</code> 录音，进行语音识别，识别结束后，播报识别结果，但是录音还要继续，遇到的问题是播放的时候声音很小。原因是由于录音的时候设置了</p>

<pre><code>[[AVAudioSession sharedInstance] setCategory:AVAudioSessionCategoryPlayAndRecord error:nil];
</code></pre>

<p>这样设置之后，默认播放rout是听筒，而不是扬声器，声音就小了。
修改方法如下
方法一：</p>

<pre><code>[[AVAudioSession sharedInstance] setCategory:AVAudioSessionCategoryPlayAndRecord withOptions:AVAudioSessionCategoryOptionDefaultToSpeaker | AVAudioSessionCategoryOptionAllowBluetooth error:nil];
</code></pre>

<p>方法二：</p>

<pre><code>[session overrideOutputAudioPort:AVAudioSessionPortOverrideSpeaker error:&amp;error];
</code></pre>

<p>这两个方法的区别可以看这里<a href="https://developer.apple.com/library/ios/qa/qa1754/_index.html">AVAudioSessionCategoryOptionDefaultToSpeaker和AVAudioSessionPortOverrideSpeaker区别</a>，大概意思就是设置<code>AVAudioSessionPortOverrideSpeaker</code> 是临时性的，如果rout改变和audioSession被中断的话，这个设置就失效了，会返回到默认的设置。设置<code>AVAudioSessionCategoryOptionDefaultToSpeaker</code> 后，会一直生效。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS8 framework动态库遇到的问题]]></title>
    <link href="http://githubdelegate.github.io/blog/2015/09/08/ios8chuang-jian-frameworkyu-dao-de-wen-ti/"/>
    <updated>2015-09-08T14:32:29+08:00</updated>
    <id>http://githubdelegate.github.io/blog/2015/09/08/ios8chuang-jian-frameworkyu-dao-de-wen-ti</id>
    <content type="html"><![CDATA[<ol>
<li><p>编译显示<code>Include of non-modular header inside framework module</code> 错误</p>

<p>  修改<code>Build Setting</code> 中<code>Allow Non-modular Include InFramework Modules</code> 为YES.</p></li>
<li><p>在代码中引用头文件 <code>#import "***Kit.h"</code> 提示找不到</p>

<p> 这个时候要检查对应的framework target <code>Build Phases-&gt;Headers-&gt;Public</code> 是否包含对应的类。一般要提供给其他target使用的类的.h文件都应该放到Public中.</p></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS使用AudioQueue录音遇到的内存泄露问题]]></title>
    <link href="http://githubdelegate.github.io/blog/2015/08/04/ios-nei-cun/"/>
    <updated>2015-08-04T00:15:17+08:00</updated>
    <id>http://githubdelegate.github.io/blog/2015/08/04/ios-nei-cun</id>
    <content type="html"><![CDATA[<h3>AudioQueue 录音</h3>

<p><code>AudioQueue</code> 是iOS中比较底层的音频处理类，可以用来播放和录音。录音的话，每个一段时间都会通过一个C的回掉函数返回录音数据。如下面的代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// 回调函数
</span><span class='line'>void inputBufferHandler(void *inUserData, AudioQueueRef inAQ, AudioQueueBufferRef inBuffer, const AudioTimeStamp *inStartTime,
</span><span class='line'>                        UInt32 inNumPackets, const AudioStreamPacketDescription *inPacketDesc)
</span><span class='line'>{
</span><span class='line'>    Recorder *recorder = (__bridge Recorder *)inUserData;
</span><span class='line'>    if (recorder == nil){
</span><span class='line'>        return;
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    if ((inNumPackets &gt; 0) && (recorder.isRecording))
</span><span class='line'>    {
</span><span class='line'>         // 获取录音数据
</span><span class='line'>        int _pcmSize = inBuffer-&gt;mAudioDataByteSize;
</span><span class='line'>        char *_pcmData = (char *)inBuffer-&gt;mAudioData;
</span><span class='line'>      
</span><span class='line'>        NSData *data = [[NSData alloc] initWithBytes:_pcmData length:_pcmSize];
</span><span class='line'>        // 把录音数据传递出去
</span><span class='line'>        [recorder writeRecordingData:data];
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<hr />

<p>上面这段代码有问题，如果一直不停的录音，会发现内存一直不停的增加，而且每次增加的大小会和每次返回的录音数据大小相等。
那导致这段代码内存泄露的原因，就是<code>NSData *data = [[NSData alloc] initWithBytes:_pcmData length:_pcmSize];</code> 这段代码中<code>data</code> 没有释放导致的。虽然是在ARC环境下，但是这是个C函数，要自己管理内存，所以加上<code>@autorelease</code> 就能解决。</p>

<hr />

<blockquote><p>引用
<a href="http://memo.tv/archive/memory_management_with_objective_c_cocoa_iphone">Memory Management with Objective C / Cocoa / iPhone </a></p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Octopress搭建博客中遇到的问题]]></title>
    <link href="http://githubdelegate.github.io/blog/2015/07/24/blog/"/>
    <updated>2015-07-24T00:15:17+08:00</updated>
    <id>http://githubdelegate.github.io/blog/2015/07/24/blog</id>
    <content type="html"><![CDATA[<ul>
<li><p><code>gem install **</code> 提示安装失败</p>

<ul>
<li><p>修改gem source<br/>
<code>gem sources -a https://ruby.taobao.org/</code> 添加
<code>gem sources -r https://rubygems.org/</code> 删除原来的</p></li>
<li><p>如果使用<code>bundle install</code> 的时候，安装失败，需要修Gemfile
<code>修改Gemfile 中 source 为https://ruby.taobao.org/</code></p></li>
</ul>
</li>
<li><p>使用<code>zsh</code> 遇到 <code>rake new_post[“title”]</code>  提示 <code>zsh: no matches found: new_post[...]</code></p>

<ul>
<li>修改~/.zshrc文件 添加 <code>alias rake="noglob rake"</code></li>
</ul>
</li>
</ul>


<hr />

<p>相关blog</p>

<ol>
<li><a href="http://www.tuicool.com/articles/Av6fqu">http://www.tuicool.com/articles/Av6fqu</a></li>
<li><a href="http://glgjing.github.io/blog/2014/12/06/li-yong-octopresshe-githubda-jian-ge-ren-bo-ke-(%5B%3F%5D-):ji-chu-huan-jing-da-jian/">http://glgjing.github.io/blog/2014/12/06/li-yong-octopresshe-githubda-jian-ge-ren-bo-ke-(%5B%3F%5D-):ji-chu-huan-jing-da-jian/</a></li>
</ol>

]]></content>
  </entry>
  
</feed>
