
<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>Alpine Blog</title>
	<meta name="author" content="zy">

	
	<meta name="description" content="ios, 动画 Comments UIView在执行动画过程中如何响应点击事件 UIView在执行动画过程中如何响应事件 先看代码 1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18 - (void)viewDidLoad { [super &hellip;">
	

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

	<link href="/atom.xml" rel="alternate" title="Alpine Blog" type="application/atom+xml">
	
	<link rel="canonical" href="http://githubdelegate.github.io/">
	<link href="/favicon.png" rel="shortcut icon">
	<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
	<script src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
	<link href='http://fonts.googleapis.com/css?family=Open+Sans:400italic,400,700' rel='stylesheet' type='text/css'>
	
</head>


<body>
	<div class="container">
		<div class="left-col">
			<div class="intrude-less">
			<header id="header" class="inner"><div class="profilepic">	
	<script src="/javascripts/md5.js"></script>
	<script type="text/javascript">
		document.write("<img src='http://www.gravatar.com/avatar/" + MD5("") + "?s=160' alt='Profile Picture' style='width: 160px;' />");
	</script>
</div>
<h1><a href="/">Alpine Blog</a></h1>
<p class="subtitle">keep learning</p>
<nav id="main-nav"><ul class="main">
    <li><a href="/">Blog</a></li>
    <li><a href="http://about.me/shashankmehta">About</a></li>
    <li><a href="/blog/archives">Archives</a></li>
</ul></nav>
<nav id="sub-nav">
	<div class="social">
		
		
		
		
		
		<a class="github" href="https://github.com/githubdelegate" title="GitHub">GitHub</a>
		
		
		
		
		
		
		
		<a class="rss" href="/atom.xml" title="RSS">RSS</a>
		
	</div>
</nav>

</header>				
			</div>
		</div>	
		<div class="mid-col">
			
				
			
			<div class="mid-col-container">
				<div id="content" class="inner">
<div itemscope itemtype="http://schema.org/Blog">


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2016-05-16T20:32:50+08:00" data-updated="true" itemprop="datePublished"></time></div>
		<div class="tags">


	<a class='category' href='/blog/categories/ios/'>ios</a>, <a class='category' href='/blog/categories/dong-hua/'>动画</a>


</div>
		
			<span class="comments"><a href="/blog/2016/05/16/uiviewzai-zhi-xing-dong-hua-guo-cheng-zhong-ru-he-xiang-ying-dian-ji-shi-jian/#disqus_thread">Comments</a></span>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2016/05/16/uiviewzai-zhi-xing-dong-hua-guo-cheng-zhong-ru-he-xiang-ying-dian-ji-shi-jian/" itemprop="url">UIView在执行动画过程中如何响应点击事件</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<h1>UIView在执行动画过程中如何响应事件</h1>

<p>先看代码</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>- (void)viewDidLoad {
</span><span class='line'>    [super viewDidLoad];
</span><span class='line'>
</span><span class='line'>    UIButton *btn = [[UIButton alloc] initWithFrame:CGRectMake(100, 100, 100, 40)];
</span><span class='line'>    self.btn = btn;
</span><span class='line'>    [btn addTarget:self action:@selector(btnClick) forControlEvents:UIControlEventTouchUpInside];
</span><span class='line'>    btn.backgroundColor = [UIColor greenColor];
</span><span class='line'>    [self.view addSubview:btn];
</span><span class='line'>    
</span><span class='line'>}
</span><span class='line'>- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event{
</span><span class='line'>    [UIView animateWithDuration:15 delay:0 options:UIViewAnimationCurveLinear | UIViewAnimationOptionAllowUserInteraction animations:^{
</span><span class='line'>         self.btn.frame = CGRectMake(300, 100, 100, 40);
</span><span class='line'>    } completion:^(BOOL finished) {
</span><span class='line'>        
</span><span class='line'>    }];
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>上面是一段很简单的动画代码，问题是在btn做动画，移动过程中，btn不能响应点击事件了。这是因为其实btn 接受事件的区域已经移动到300的位置，你点击300会发现触发了点击事件。实际的动画过程就是<code>.layer.presentationLayer</code>在做，就是你能看到的移动过程实际上是<code>.layer.presentationLayer</code>.所以要判断要想在动画过程中响应点击事件就需要判断手指点击的点是不是在<code>.layer.presentationLayer</code>上，使用UIView方法 <code>hitTest:withEvent:</code>方法，这个方法会返回一个View，就是在当前View的层级结构中找到一个最合适的View来处理事件。
    大概的过程就是先调用<code>pointInside:withEvent:</code>方法，判断触摸点是不是在当前View中，若返回NO,表示触摸点不在当前View上，<code>hitTest:withEvent:</code>方法返回nil；若返回YES，表示触摸点在当前View内，然后从subviews数组中<code>尾部向前遍历</code>,每个子View同样执行这两个方法，直到有子视图的hitTest:withEvent:方法返回非空对象或者全部子视图遍历完毕。▷ 若第一次有子视图的hitTest:withEvent:方法返回非空对象,则当前视图的hitTest:withEvent:方法就返回此对象，处理结束
▷ 若所有子视图的hitTest:withEvent:方法都返回nil，则当前视图的hitTest:withEvent:方法返回当前视图自身(self)
• 最终，这个触摸事件交给主窗口的hitTest:withEvent:方法返回的视图对象去处理。</p>

<p>现在考虑为什么使用<code>layer.presentationLayer</code>,这个可以看<a href="http://objccn.io/issue-12-1/">动画解释</a>,</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if ([self.layer.presentationLayer hitTest:touchedPoint]){
</span><span class='line'>    CGPoint newPoint = [self.layer.presentationLayer convertPoint:touchedPoint fromLayer:self.superview.layer];
</span><span class='line'>    NSLog(@"得到新的点=%@",NSStringFromCGPoint(newPoint));
</span><span class='line'>    if (newPoint.x &gt; 0 && newPoint.x &lt; 35) {
</span><span class='line'>        if (self.bulletViewHeadImageTappedBlock) {
</span><span class='line'>            self.bulletViewHeadImageTappedBlock(self.infoDict);
</span><span class='line'>        }
</span><span class='line'>        return YES;
</span><span class='line'>    }
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p>看这段代码，<code>hitTest:touchedPoint</code>有返回值表示点击点在self.layer.presentationLayer范围内，然后就是转换坐标系把点击点转换到<code>self.layer.presentationLayer</code>坐标系里面，就可以判断具体点击在哪个视图上了。</p>

<blockquote><p>未完下次继续分析动画</p>

<p><a href="http://www.superqq.com/blog/2015/04/23/iosyong-hu-dian-ji-shi-jian-chu-li/">http://www.superqq.com/blog/2015/04/23/iosyong-hu-dian-ji-shi-jian-chu-li/</a></p></blockquote>

		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2016-03-02T17:14:33+08:00" data-updated="true" itemprop="datePublished"></time></div>
		<div class="tags">

</div>
		
			<span class="comments"><a href="/blog/2016/03/02/iosxiang-guan-zheng-shu-quan-bu-shi-xiao/#disqus_thread">Comments</a></span>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2016/03/02/iosxiang-guan-zheng-shu-quan-bu-shi-xiao/" itemprop="url">iOS相关证书全部失效</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>某天打开电脑突然发现iOS相关证书全部失效。全部显示<code>证书的签发者无效</code>。</p>

<p>先找到一个失效证书，右击->评估证书->代码签名->显示证书，可以看到证书失效的原因：
<img src="http://i.imgur.com/LxwxgAi.png?1" alt="图片" /></p>

<p>去这个地址下载最新证书：<code>https://developer.apple.com/certificationauthority/AppleWWDRCA.cer</code> 安装.
同时要把老证书全部删掉，在keychains里选择login,然后点选Certificates，在这个界面，选择工具栏的View -> Show Expired Certificates，这时候你会发现一个过期的“WWDR Certificate”（Apple Worldwide Developer Relations Certification Authority），删除它，同样的办法，在System的那一栏也有这个过期的“WWDR Certificate”.
如果过期证书全部删除，并且已安装新证书，会发现证书全部都OK了。</p>

<blockquote><p><a href="https://segmentfault.com/q/1010000004433963">https://segmentfault.com/q/1010000004433963</a></p></blockquote>

		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2016-01-04T14:34:43+08:00" data-updated="true" itemprop="datePublished"></time></div>
		<div class="tags">


	<a class='category' href='/blog/categories/swift/'>swift</a>


</div>
		
			<span class="comments"><a href="/blog/2016/01/04/oczhuan-swift-cuo-wu-ji-lu/#disqus_thread">Comments</a></span>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2016/01/04/oczhuan-swift-cuo-wu-ji-lu/" itemprop="url">Oc转swift 错误记录</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<h2>1.option enum -> OptionSetType</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rightView.autoresizingMask = UIViewAutoresizingFlexibleLeftMargin |UIViewAutoresizingFlexibleTopMargin;
</span><span class='line'>  </span></code></pre></td></tr></table></div></figure>


<p>转</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>self.rightView?.autoresizingMask = [.FlexibleTopMargin,.FlexibleLeftMargin]</span></code></pre></td></tr></table></div></figure>


<ul>
<li><p>MIN -> min</p></li>
<li><p>3.swift 闭包中的循环引用</p>

<blockquote><p><a href="http://southpeak.github.io/blog/2014/06/27/ios-swift-closures-2/">Swift闭包二：循环引用</a></p></blockquote></li>
<li><p>4.swift中和NSRange相关接口使用</p></li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let levels = "ABCDE"
</span><span class='line'>
</span><span class='line'>let nsRange = NSMakeRange(1, 4)
</span><span class='line'>// 编译错误
</span><span class='line'>// 'NSRange' is not convertible to 'Range&lt;String.Index&gt;'
</span><span class='line'>levels.stringByReplacingCharactersInRange(nsRange, withString: "AAAA")
</span><span class='line'>
</span><span class='line'>let indexPositionOne = levels.startIndex.successor()
</span><span class='line'>let swiftRange = indexPositionOne..&lt;advance(indexPositionOne, 4)
</span><span class='line'>levels.stringByReplacingCharactersInRange(swiftRange, withString: "AAAA")
</span><span class='line'>// 输出：
</span><span class='line'>// AAAAA</span></code></pre></td></tr></table></div></figure>


<p>上面的方法太麻烦啦。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let nsRange = NSMakeRange(1, 4)
</span><span class='line'>(levels as NSString).stringByReplacingCharactersInRange(
</span><span class='line'>    nsRange, withString: "AAAA")</span></code></pre></td></tr></table></div></figure>


<ul>
<li>5 中文转拼音</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>+ (NSString *)pinyinString:(NSString *)string
</span><span class='line'>{
</span><span class='line'>
</span><span class='line'>    NSMutableString *mutableString = [NSMutableString stringWithString:string];
</span><span class='line'>    CFStringTransform((CFMutableStringRef)mutableString, NULL, kCFStringTransformToLatin, false);
</span><span class='line'>    CFStringTransform((CFMutableStringRef)mutableString, NULL, kCFStringTransformStripDiacritics, false);
</span><span class='line'>    NSLog(@"%@",mutableString);
</span><span class='line'>    return mutableString;
</span><span class='line'>}
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure>


		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2016-01-04T11:06:33+08:00" data-updated="true" itemprop="datePublished"></time></div>
		<div class="tags">


	<a class='category' href='/blog/categories/uiappearance/'>uiappearance</a>


</div>
		
			<span class="comments"><a href="/blog/2016/01/04/ios-uiappearanceshi-yong/#disqus_thread">Comments</a></span>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2016/01/04/ios-uiappearanceshi-yong/" itemprop="url">iOS UIAppearance使用</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<h1>iOS UIAppearance使用</h1>

<h3>为什么要使用 <code>UIAppearance</code></h3>

<p>在iOS 5以前，自定义原生控件的外观并没有原生支持，因此开发人员感觉很麻烦。开发人员经常面临的问题是修改一个控件所有实例的外观。解决这个问题的正确方法是重写一遍控件。但由于这么做非常费时，一些开发人员开始覆盖或混写一些方法，如drawRect:。</p>

<p>从iOS 5开始，苹果通过两个协议（UIAppearance和UIAppearanceContainer）规范了对许多UIKit控件定制的支持。所有遵循UIAppearance协议的UI控件通过定制都可以呈现各种外观。不仅如此，UIAppearance协议甚至允许开发者基于控件所属的区域指定不同的外观。也就是说，当某个控件包含在特定视图中时，可以指定它的外观（如UIBarButtonItem的tintColor）。也可以获取该控件类的外观代理对象，用该代理定制外观来实现，下面来看一个例子</p>

<p>iOS5及其以后提供了一个比较强大的工具UIAppearance，我们通过UIAppearance设置一些UI的全局效果，这样就可以很方便的实现UI的自定义效果又能最简单的实现统一界面风格，它提供如下两个方法。</p>

<p><code>+ (id)appearance</code>
这个方法是统一全部改，比如你设置UINavBar的tintColor，你可以这样写：[[UINavigationBar appearance] setTintColor:myColor];</p>

<p><code>+ (id)appearanceWhenContainedIn:(Class &lt;&gt;)ContainerClass,...</code>
这个方法可设置某个类的改变：例如：设置UIBarButtonItem 在UINavigationBar、UIPopoverController、UITabbar中的效果。就可以这样写
[[UIBarButtonItem appearanceWhenContainedIn:[UINavigationBar class], [UIPopoverController class],[UITabbar class] nil] setTintColor:myPopoverNavBarColor];</p>

<pre><code>请注意＊使用appearance设置UI效果最好采用全局的设置，在所有界面初始化前开始设置，否则可能失效。
</code></pre>

<p>但是它并不是支持所有的UI类。下面列出它支持的类</p>

<p>　　1.UIActivitiIndicatorView</p>

<p>　　2.UIBarButtonItem</p>

<p>　　3.UIBarItem</p>

<p>　　4.UINavgationBar</p>

<p>　　5.UIPopoverControll</p>

<p>　　6.UIProgressView</p>

<p>　　7.UISearchBar</p>

<p>　　8.UISegmentControll</p>

<p>　　9.UISlider</p>

<p>　　10.UISwitch</p>

<p>　　11.UITabBar</p>

<p>　　12.UITabBarItem</p>

<p>　　13.UIToolBar</p>

<p>　　14.UIView</p>

<p>　　15.UIViewController
　　</p>

<h3>自己创建一个可自定义外观的控件</h3>

<p>对于我们自己定义的控件，也可以支持UIAppearance协议，这样我们的控件也能支持自定义了。你只需要写一个设置外观的settor，然后在settor方法后面加上“UI_APPEARANCE_SELECTOR”标记就可以。</p>

<h3>UIAppearance实现原理</h3>

<p>在通过UIAppearance调用“UI_APPEARANCE_SELECTOR”标记的方法来配置外观时，UIAppearance实际上没有进行任何实际调用，而是把这个调用保存起来（在Objc中可以用NSInvocation对象来保存一个调用）。当实际的对象显示之前（添加到窗口上，drawRect:之前），就会对这个对象调用之前保存的调用。当这个setter调用后，你的界面风格自定义就完成了。</p>

		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2016-01-02T15:50:05+08:00" data-updated="true" itemprop="datePublished"></time></div>
		<div class="tags">

</div>
		
			<span class="comments"><a href="/blog/2016/01/02/iosduo-xian-cheng-yi/#disqus_thread">Comments</a></span>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2016/01/02/iosduo-xian-cheng-yi/" itemprop="url">iOS多线程一</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<h2>1.3多线程方案</h2>

<table>
<thead>
<tr>
<th>技术 </th>
<th> 描述 </th>
</tr>
</thead>
<tbody>
<tr>
<td>Operation objects </td>
<td> 一个operation对象是一个任务的包装，可以在子线程中正常的执行。这层包装隐藏了线程的管理，让你专心任务本身。你要把它和operation queue相结合。operation queue可以在多个线程中管理operation对象。  | Content Cell</td>
</tr>
<tr>
<td>GCD </td>
<td> GCD 是另一种使用多线程的方式，能让你专注于你的任务而不用担心线程管理。使用GCD,你设计你的任务，把任务添加到一个queue，queue负责调度你的任务在合适的线程。queue会计算当前可用的资源，让你的任务更高效的执行。  | Content Cell</td>
</tr>
<tr>
<td>Idle-time notifications</td>
<td> 对于一些很短，优先级很低的任务，空闲时间通知会在你的程序空闲的时候执行任务。Cocoa 用<code>NSNotificationQueue</code>提供了支持。 |</td>
</tr>
<tr>
<td>Asynchronous functions</td>
<td>系统接口提供了很多异步函数可以自动同步。这些API使用系统用户进程或者创建线程去执行任务，并把结果给你。|</td>
</tr>
<tr>
<td>Timers</td>
<td>你可以使用timers 在主线程中去执行定期的任务，这些任务|</td>
</tr>
</tbody>
</table>


<h3>1.3.1 线程包装</h3>

<p>在应用层，全部的线程本质上都是一样的。开启一个线程后，线程运行状态有三种：<code>running</code>,<code>ready</code>,<code>blocked</code>。当一个线程当前不是运行，那么它可能是blocked，等待输入，或者是ready，等待调度。线程一直在这些状态中交替，直到退出，进入结束状态。
当你创建一个线程，你必须明确一个入口函数，入口函数构建在线程运行的代码。当函数返回或者你明确的结束线程，线程永远的停止并且会被系统回收。因为线程很消耗内存和时间，所以推荐你的入口函数处理大量的工作，或者创建一个<code>run loop</code>去做一些周期重复的工作。</p>

<h3>1.3.2 Run Loops</h3>

<p> 一个run loop就是用来在线程中管理异步到达的事件的一种机制。一个runloop工作原理就是监控一个或多个事件源。当事件到达，系统唤醒线程，调度事件到runloop，把事件调度给你设置的handlers。如果当前没有事件处理，runloop就把线程sleep。
并不要求你在线程中使用runloop，如果使用runloop可以给用户更好的体验。runloop可以保证线程使用最小的资源长期的存活下去，因为runloop会让线程进入睡眠状态，当线程无事可做的时候。它不需要不断的轮询，避免浪费CPU周期和防止处理器本身从睡觉和节约能源。
配置一个runloop，你不得不开启你的线程，获得一个你的线程的引用，安装你的事件handlers，然后告诉runloop run即可。OS X 的主线程已经配置好了runloop。如果你打算创建一个长期生存的线程，你必须为线程配置runloop。</p>

<h3>1.3.3 同步工具</h3>

<p> 多线程编程的一个最危险的就是多线程间的资源的争夺。如果多个线程尝试使用或修改同样的资源在同一时刻，问题就会出现。
Lock 提供一种狂野的方式保护一个时刻只能被一个线程执行的代码。最常见的锁是互斥锁，
系统还提供了条件变量conditions，用来保证程序中正确的任务执行顺序。一个条件就像门卫，阻塞线程直到条件为真。</p>

<h3>1.3.4 线程间的交互</h3>

<table>
<thead>
<tr>
<th>机制</th>
<th>简介</th>
</tr>
</thead>
<tbody>
<tr>
<td>Direct messaging</td>
<td>Cocoa支持直接在别的线程执行方法</td>
</tr>
<tr>
<td>Global variables, shared memory, and objects</td>
<td></td>
</tr>
<tr>
<td>Condition</td>
<td></td>
</tr>
<tr>
<td>Run loop sources</td>
<td></td>
</tr>
</tbody>
</table>


<h2>3.Run Loops</h2>

		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2015-12-31T10:24:12+08:00" data-updated="true" itemprop="datePublished"></time></div>
		<div class="tags">

</div>
		
			<span class="comments"><a href="/blog/2015/12/31/xue-xi-bloc/#disqus_thread">Comments</a></span>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2015/12/31/xue-xi-bloc/" itemprop="url">学习block</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<blockquote><p><a href="https://www.zybuluo.com/MicroCai/note/57603">block没那么难</a></p></blockquote>

<h2>1.block 基本构成</h2>

<h3>2.<code>__block</code> 和 <code>__weak</code> 区别</h3>

<ol>
<li><p><strong>block 在 ARC 和非 ARC 下含义一样吗？
</strong>block 在 ARC 下捕获的变量会被 block retain, 这样可能导致循环引用, 所以必须要使用弱引用才能解决该问题. 而在非 ARC 下, 可以直接使用 __block 说明符修饰变量, 因为在非 ARC 下, block 不会 retain 捕获的变量.</p></li>
<li><p>以下 keywords 有什么区别: assign vs weak, <strong>block vs </strong>weak
assign 和 weak 是用于在声明属性时, 为属性指定内存管理的语义.</p></li>
</ol>


<p>assign 用于简单的赋值, 不改变属性的引用计数, 用于 Objective-C 中的 NSInteger, CGFloat 以及 C 语言中 int, float, double 等数据类型.
weak 用于对象类型, 由于 weak 同样不改变对象的引用计数且不持有对象实例, 当该对象废弃时, 该弱引用自动失效并且被赋值为 nil, 所以它可以用于避免两个强引用产生的循环引用导致内存无法释放的问题.
<strong>block 和 </strong>weak 之间的却是确实极大的, 不过它们都用于修饰变量.</p>

<p>前者用于指明当前声明的变量在被 block 捕获之后, 可以在 block 中改变变量的值. 因为在 block 声明的同时会截获该 block 所使用的全部自动变量的值, 而这些值只在 block 中只具有"使用权"而不具有"修改权". 而 <strong>block 说明符就为 block 提供了变量的修改权.
后者是所有权修饰符, 什么是所有权修饰符? 这里涉及到另一个问题, 因为在 ARC 有效时, id 类型和对象类型同 C 语言中的其他类型不同, 必须附加所有权修饰符. 所有权修饰符一种有 4 种:
</strong>strong
<strong>weak
</strong>unsafe_unretained
<strong>autorelease
</strong>weak 与 weak 的区别只在于, 前者用于变量的声明, 而后者用于属性的声明.</p>

		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2015-12-30T14:41:25+08:00" data-updated="true" itemprop="datePublished"></time></div>
		<div class="tags">

</div>
		
			<span class="comments"><a href="/blog/2015/12/30/ios-could-not-find-foundation-module-error/#disqus_thread">Comments</a></span>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2015/12/30/ios-could-not-find-foundation-module-error/" itemprop="url">iOS Could Not Find Foundation Module Error</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<h1>iOS Xcode 编译遇到<code>could not find Foudation module</code> 错误</h1>

<p>在pch 文件中引用 <code>#import &lt;Foundation/Foundation.h&gt;</code> 出错
解决办法：添加<code>#ifdef __OBJC__ 在这里引用 #endif</code></p>

		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2015-12-28T20:30:35+08:00" data-updated="true" itemprop="datePublished"></time></div>
		<div class="tags">

</div>
		
			<span class="comments"><a href="/blog/2015/12/28/ios-duo-xian-cheng-gcdhe-nsoperation/#disqus_thread">Comments</a></span>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2015/12/28/ios-duo-xian-cheng-gcdhe-nsoperation/" itemprop="url">iOS 多线程GCD和NSOperation</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<h3>GCD和NSOperation使用说明</h3>

<p>1.<code>NSOperation</code></p>

<p> 1.NSOperation 类是一个抽象类，用来概括一个单独的任务的代码和数据。因为它是抽象类，所以要用他的子类，或者系统定义的子类（<code>NSInvocationOperation</code> &amp;&amp; <code>NSBlockOperation</code>）去执行真正的任务。尽管是抽象类，但是<code>NSOperation</code>的实现包括了重要的逻辑可以用来协调任务的安全执行。这种内建的逻辑可以让你集中精力在任务的实现上，而不是为了保证任务的正确运行而写的各种控制粘合代码。
 一个operaton对象是一个单发对象，意味着它执行任务一次完成后，就不能再执行了。你必须把operations对象添加到operation queue，才能执行它们。一个operation queue执行它的operations即可以通过在子线程中直接执行，也可以间接的使用GCD.
如果你不想使用operation queue，你也可以通过直接调用<code>start</code>方法。因为start 一个不是在ready状态的operation，会导致exception，所以手动的执行operation会给代码带来负担。<code>ready</code>属性依据operation的准备就绪状态。</p>

<p>1.1 <code>Operation Dependencies</code></p>

<p>依赖是一个很方便的方法来让operation按照某种顺序执行。你可以通过<code>addDependency:</code> 和 <code>removeDependency:</code>方法来添加或者删除依赖。默认，一个有依赖的operation ，不能进入准备就绪状态，直到它的所有的依赖的operation执行完。一旦依赖的最后一个Operation 执行完毕，它就进入ready并且可以执行了。
NSOperation的依赖之间并没有区别，不管一个被依赖的operation是成功的执行完成，还是不成功的，（换就话说就是，取消一个operation也是表示一个operation结束。）由你决定一个有依赖的operation是不是继续，当它的依赖operation被取消了，或者没有成功的执行完成。这就要求你在你的operation里面加上额外的错误跟踪机制。</p>

<p>1.2 <code>KVO-Compliant Properties</code></p>

<p><code>NSOperation</code> 类的属性可以使用KVC&amp;KVO.
isCancelled - read-only
isAsynchronous - read-only
isExecuting - read-only
isFinished - read-only
isReady - read-only
dependencies - read-only
queuePriority - readable and writable
completionBlock - readable and writable</p>

<p>尽管你可以给这些属性添加观察者，但是你不应该把这些属性绑定上和界面相关的。因为界面相关的内容必须在主线程中执行。但是一个operation可能在任何一个线程中执行，同理KVO的通知也有可能在任何线程中执行。
如果你自己实现前面的属性，你的实现一定要遵从KVC&amp;KVO,如果你定义了额外的属性，推荐你也让这些属性遵循KVC&amp;KVO。</p>

<p>1.3 <code>Multicore Considerations</code></p>

<p><code>NSOperation</code> 类是支持多核的。所以不需要添加lock也能安全的访问NSOperation对象。这种行为是必要的,因为一个操作通常运行在一个单独的线程的创建和监控。当你自定义了一个NSOperation的子类，你必须保证任何覆盖的昂达保持线程安全。如果你自定义了一些方法，比如自定义的数据访问，你必须保证线程安全，意味着任何的访问变量的操作都必须是同步的，防止潜在数据污染。</p>

<p>1.4 <code>Asynchronous Versus Synchronous Operations</code></p>

<p>如果你计划执行一个operation手动的，你应该设计你的Operation以同步或者异步的方式执行，而不是把它添加到queue中。
Operation默认是同步的方式。在同步的方式中，operation不会创建一个新线程去执行，当你调用<code>start</code>方法的时候，operation在当前线程执行。当start方法返回的时候，任务执行完成。
当你调用一个异步的operation的start方法，start会在对应的任务完成之前返回。一个异步的operation对象有责任在子线程中安排它的任务。operation可以通过直接开启一个新线程，调用一个异步方法，或者使用GCD.如果operation正在执行，方法返回了，这并没有关系，只要operation还在进行中就行。</p>

<p>如果你只要考虑使用queue去执行你的operations。把它们定义成同步的会很简单。如果你要执行你的Operation手动的，所以你可能希望定义你的operation是异步的。定义一个异步的operation要求更多的工作量，因为你必须监控你的任务的运行状态，用KVO通知状态变化。但是定义一个异步的Operation很有用，当你手动执行operaiton并且不希望阻塞调用线程的时候。
当你添加一个operation到一个queue的时候，queue不在乎异步的属性，总是直接在异步线程调用start方法。所以如果你一直通过添加operation到queue的方法去执行operation，根本没有必要让operation是异步的。</p>

<p>1.5 <code>Subclassing Notes</code></p>

<p><code>NSOPeration</code>类提供了基本的逻辑来追踪执行状态，但是必须继承它才能干实际的工作。怎么创建你的子类，依赖于你
怎么设计你的operation，是并发的还是不并发的。</p>

<ul>
<li><p>对于不并发的opeartion，你只需要重写一个<code>main</code>方法：在这个方法中，放置任务需要执行的代码。你应该自己定义一个初始化方法，让创建实例更简单。也可以定义<code>getter</code> <code>setter</code>方法，你必须保证这些方法是多线程安全的。</p></li>
<li><p>对于并发的operation，至少需要重写<code>start</code>,<code>asynchronous</code>,<code>executing</code>,<code>finished</code>方法。在并发操作中，你的start方法要开启operation异步地，不论是创建一个新线程还是调用异步的方法。一旦开启了operation，你的start方法还要更新executing属性状态，发送KVO通知。一旦执行完成或者取消执行了，你的同步的operation对象必须发送KVO通知，对应的<code>isExecuting</code> 和<code>isFInished</code>属性。(如果是取消，更新isFinisheh很重要，尽管Operation没有完整的完成任务)。</p></li>
</ul>


<p>2.<code>NSInvocationOperation</code></p>

<p><code>start</code>方法：这个方法的默认实现是更新operation执行状态，调用<code>main</code>方法。当然这个方法也会检查确保operation可以run。例如，如果cancelled，或者finished，就不会调用main方法直接返回。如果operation当前正在运行或者还没准备好运行，会抛出<code>NSInvalidArgumentException</code>异常。
注意:如果一个operation依赖一些还没finished的operations，那么就认为当前operation还没进入ready状态。
如果你是实现一个同步operation，你必须重写start方法，在start方法里面初始化operation。你自己的start方法不能调用父类的start方法。为了设置运行环境，你的实现必须根据情况改变运行的状态。当operaton开始执行，然后结束运行的时候，要发送KVO通知，<code>isExecting</code> 和<code>isFinished</code>。
如果你想主动主动的执行你的operations，你可以直接调用<code>start</code>方法。然而，对一个已经添加到queue的operation调用start方法是错误的。把一个已经调用过start方法的operation添加到queue，也是错误的。一旦把一个operation添加到queue，queue就会对这个operation全权负责了，你不需要关心了。</p>

<h4><code>NSBlockOperation&amp;NSInvocationOperation</code></h4>

<p><code>NSBlockOperation</code> 管理多个block的同步执行。你可以用这个对象一次执行多个block而不用分开创建不同的operation对象。当执行多个block的时候，只有当全部的block finished才算这个operation finished。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>   
</span><span class='line'>       NSBlockOperation *blockOperation = [NSBlockOperation blockOperationWithBlock:^{
</span><span class='line'>        NSLog(@"1th block--current thread:%@",[NSThread currentThread]);
</span><span class='line'>    }];
</span><span class='line'>    
</span><span class='line'>    // operation的所以block执行完成后，才会执行。在当前线程中执行。
</span><span class='line'>    blockOperation.completionBlock = ^(){
</span><span class='line'>        NSLog(@"blockoperaton 完成啦啦啦啦啦---current thread:%@",[NSThread currentThread]);
</span><span class='line'>    };
</span><span class='line'>    
</span><span class='line'>    [blockOperation addExecutionBlock:^{
</span><span class='line'>        NSLog(@"2th block--current thread:%@",[NSThread currentThread]);
</span><span class='line'>    }];
</span><span class='line'>    
</span><span class='line'>    [blockOperation addExecutionBlock:^{
</span><span class='line'>        NSLog(@"add 3th block--current thread:%@",[NSThread currentThread]);
</span><span class='line'>    }];
</span><span class='line'>    
</span><span class='line'>    // 1.手动start执行，第一个block会在当前线程中执行，其余block会在异步线程中
</span><span class='line'>    // [blockOperation start];
</span><span class='line'>    
</span><span class='line'>    // 2.放到queue中执行，queue会把其中的operation放在异步线程中执行，所以block会全部在异步线程中执行。并且是并发执行。
</span><span class='line'>    [[[NSOperationQueue alloc] init] addOperation:blockOperation];
</span><span class='line'>    
</span><span class='line'>//##---------------------------------------------
</span><span class='line'>    NSInvocationOperation *invocationOperation = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(run:) object:@"123"];
</span><span class='line'>    invocationOperation.completionBlock = ^(){
</span><span class='line'>        NSLog(@"invocation完成--current thread:%@",[NSThread currentThread]);
</span><span class='line'>    };
</span><span class='line'>    
</span><span class='line'>    // 1.手动start执行.在当前线程中执行。
</span><span class='line'>    // [invocationOperation start];
</span><span class='line'>    
</span><span class='line'>    // 2.放到queue中执行，queue会把其中的operation放在异步线程中执行.
</span><span class='line'>    [[[NSOperationQueue alloc] init] addOperation:invocationOperation];
</span></code></pre></td></tr></table></div></figure>


<p>输出结果：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>2015-12-29 15:15:29.222 NSOperationTest[62550:4394450] add 3th block--current thread:&lt;NSThread: 0x796677a0&gt;{number = 4, name = (null)}
</span><span class='line'>2015-12-29 15:15:29.222 NSOperationTest[62550:4394449] 2th block--current thread:&lt;NSThread: 0x79667970&gt;{number = 5, name = (null)}
</span><span class='line'>2015-12-29 15:15:29.222 NSOperationTest[62550:4394436] 1th block--current thread:&lt;NSThread: 0x79667670&gt;{number = 3, name = (null)}
</span><span class='line'>2015-12-29 15:15:29.222 NSOperationTest[62550:4394453] invocationOperaton---current thread:&lt;NSThread: 0x7978c4d0&gt;{number = 6, name = (null)}--obj=123
</span><span class='line'>2015-12-29 15:15:29.225 NSOperationTest[62550:4394449] invocation完成--current thread:&lt;NSThread: 0x79667970&gt;{number = 5, name = (null)}
</span><span class='line'>2015-12-29 15:15:29.225 NSOperationTest[62550:4394453] blockoperaton 完成啦啦啦啦啦---current thread:&lt;NSThread: 0x7978c4d0&gt;{number = 6, name = (null)}
</span></code></pre></td></tr></table></div></figure>


<p>结论：<code>NSBlockOperation</code>添加的block会添加到<code>executionBlocks</code>中，猜测<code>start</code>方法的大概伪代码实现是</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)start
</span><span class='line'>{
</span><span class='line'>    Block block  = executionBlocks.firstObj;
</span><span class='line'>    block(); // 先执行第一个block
</span><span class='line'>
</span><span class='line'>    for (int i = 1; i&lt;executionBlocks.count; i++) {
</span><span class='line'>        dispatch_async(dispatch_get_global_queue(0, 0), ^{
</span><span class='line'>            (block)executionBlocks[i](); // 异步执行剩下的block
</span><span class='line'>        });
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    // 当前面的任务全部完成后调用完成block
</span><span class='line'>    self.completionBlock();
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p>当放入queue中时，就是再异步线程中调用当前operation的 <code>start</code>方法。</p>

<p>2.<code>GCD</code></p>

		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2015-12-28T15:57:23+08:00" data-updated="true" itemprop="datePublished"></time></div>
		<div class="tags">

</div>
		
			<span class="comments"><a href="/blog/2015/12/28/xcode-bu-xian-shi-cheng-xu-nei-cun-zhan-yong-zhuang-tai/#disqus_thread">Comments</a></span>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2015/12/28/xcode-bu-xian-shi-cheng-xu-nei-cun-zhan-yong-zhuang-tai/" itemprop="url">Xcode 不显示程序内存占用状态</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<h3>Xcode 突然不显示程序运行的内存占用信息了</h3>

<p>办法：<code>Product</code>-> <code>Scheme</code>-><code>Edit Scheme</code> -> <code>Diagnostic</code>-> <code>取消Enable Zombie Objects</code> 选项。</p>

		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2015-12-16T10:53:50+08:00" data-updated="true" itemprop="datePublished"></time></div>
		<div class="tags">


	<a class='category' href='/blog/categories/mutilthread/'>mutilthread</a>, <a class='category' href='/blog/categories/oc/'>oc</a>


</div>
		
			<span class="comments"><a href="/blog/2015/12/16/ios-duo-xian-cheng-jian-tong-bu/#disqus_thread">Comments</a></span>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2015/12/16/ios-duo-xian-cheng-jian-tong-bu/" itemprop="url">iOS 多线程间同步</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<h2>iOS 多线程同步</h2>

<hr />

<h3>线程同步概念</h3>

<p>在多线程编程里面，一些敏感数据不允许被多个线程同时访问，此时就使用同步访问技术，保证数据在任何时刻，最多有一个线程访问，以保证数据的完整性。
我们可以通过<code>互斥锁(mutex)</code>，<code>条件变量(condition variable)</code>和<code>读写锁(reader-writer lock)</code> 和<code>信号</code>来同步资源。</p>

<ul>
<li>互斥锁仅允许每次使用一个线程来执行特定的部分代码或者访问特定数据。</li>
<li>读写锁允许对受保护的共享资源进行并发读取和独占写入。要修改资源，线程必须首先获取互斥写锁。只有释放所有的读锁之后，才允许使用互斥写锁。</li>
<li>条件变量会一直阻塞线程，直到特定的条件为真。</li>
<li>计数信号量通常用来协调对资源的访问。使用计数，可以限制访问某个信号的线程数达到指定的计数时，信号将阻塞。</li>
</ul>


<hr />

<h3>iOS多线程同步的办法</h3>

<h4>1.Atomic Operations</h4>

<p>原子操作是对简单的数据类型的最简单的同步方法。用原子操作的好处是不会阻塞正在竞争的线程，这比加锁好。</p>

<h4>2.Locks</h4>

<p>锁是最常用的同步工具。你可以用锁保护一段一次只允许一个线程执行的代码块。比如，一段操作一份关键数据的代码，或者用到一些一次只允许一个用户操作的资源。通过把一个锁放在这段代码两边，可以阻止其他线程修改。
iOS 中可以使用的锁如下代码：</p>

<ul>
<li><code>1.mutex lock</code></li>
</ul>


<pre><code class="`">
  - (void)viewDidLoad {
    [super viewDidLoad];

    self.test = 10;
    pthread_mutex_init(&amp;mutex, NULL);
    pthread_mutex_lock(&amp;mutex);
    self.test+=20;
    printf("test=%d",self.test);
}

- (IBAction)btn1Click:(id)sender {
    dispatch_async(dispatch_get_global_queue(0, 0), ^{
        pthread_mutex_lock(&amp;mutex); // 如果mutex没有释放会在这里等待
        self.test+=10;
        printf("test=%d\n",self.test);
        NSLog(@"current thread:%@",[NSThread currentThread]);
        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
            pthread_mutex_unlock(&amp;mutex);
        });
    });
}

    - (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event
    {
        pthread_mutex_unlock(&amp;mutex);
    }
</code></pre>

<p> 输出：</p>

<pre><code class="`">
test=30test=40
2015-12-16 18:07:27.297 threadSynTest[5908:374571] current thread:&lt;NSThread: 0x7b246080&gt;{number = 2, name = (null)}
test=50
2015-12-16 18:07:28.392 threadSynTest[5908:374574] current thread:&lt;NSThread: 0x7b2b6ce0&gt;{number = 3, name = (null)}
test=60
2015-12-16 18:07:29.415 threadSynTest[5908:374570] current thread:&lt;NSThread: 0x7b28a530&gt;{number = 4, name = (null)}
test=70
2015-12-16 18:07:30.423 threadSynTest[5908:374575] current thread:&lt;NSThread: 0x7b26c700&gt;{number = 5, name = (null)}
</code></pre>

<ul>
<li><code>2.NSLock</code></li>
</ul>


<p> 注意: <code>NSLock</code> 在<code>POSIX threads</code> 基础上实现的。当对一个NSLock 对象调用<code>unlock</code>方法，你必须要保证和给<code>NSLock</code>对象调用<code>lock</code>方法在同一个线程。在不同的线程里unlock会导致未知的错误。连续两次调用lock方法会导致死锁。如果要递归的加锁，用<code>NSRecursiveLock</code>。对一个未加锁的lock 调用<code>unlock</code>是不正确的，要修正。</p>

<p> <code>tryLock</code> :尝试加锁，并且会立即返回，成功返回YES，不会阻塞。
 <code>lock</code> 方法: 加锁，如果当前是在锁的状态，当前线程的会阻塞，直到加锁</p>

<ul>
<li><code>3.@synchronized</code></li>
</ul>


<p> <code>@synchronized</code> 指令可以非常方便的创建互斥锁，它会像其他互斥锁一样防止不同线程在同一时刻获得相同的锁。但是你并不需要创建<code>mutex lock</code>或<code>NSLock</code> 对象，相反你只需要简单用一个OC 对象作为一个lock token.
传递给@synchronized指令的对象是唯一的，用来区别被保护的代码块。如果你在不同的线程执行这个指令，并用不同的对象作为参数，每个线程会产生自己的锁，并且会继续运行，相互之间不会相互影响。然而，如果你传递相同的对象作为参数，一个线程会先获得锁，另外一个会阻塞等待到第一个执行完成。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>- (IBAction)synchrinized:(id)sender {
</span><span class='line'>    
</span><span class='line'>    dispatch_async(dispatch_get_global_queue(0, 0), ^{
</span><span class='line'>        @synchronized(self) {
</span><span class='line'>            [self changeValue];
</span><span class='line'>            [NSThread sleepUntilDate:[NSDate dateWithTimeIntervalSinceNow:3]];
</span><span class='line'>        }
</span><span class='line'>        
</span><span class='line'>        dispatch_async(dispatch_get_main_queue(), ^{
</span><span class='line'>            @synchronized(self) {
</span><span class='line'>                [self changeValue];
</span><span class='line'>            }
</span><span class='line'>        });
</span><span class='line'>    });
</span><span class='line'>    
</span><span class='line'>    @synchronized(self) {
</span><span class='line'>        [self changeValue];
</span><span class='line'>        [NSThread sleepUntilDate:[NSDate dateWithTimeIntervalSinceNow:3]];
</span><span class='line'>    }
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>2015-12-16 19:51:18.829 threadSynTest[6717:497526] test==20---current thread:&lt;NSThread: 0x7ba3af80&gt;{number = 1, name = main}
</span><span class='line'>2015-12-16 19:51:21.831 threadSynTest[6717:497574] test==30---current thread:&lt;NSThread: 0x7b84d860&gt;{number = 2, name = (null)}
</span><span class='line'>2015-12-16 19:51:24.837 threadSynTest[6717:497526] test==40---current thread:&lt;NSThread: 0x7ba3af80&gt;{number = 1, name = main}
</span></code></pre></td></tr></table></div></figure>


<ul>
<li><code>4.NSRecursiveLock</code></li>
</ul>


<p> <code>NSRecursiveLock</code> 定义一种可以被同一个线程多次加锁而且不会引起死锁.递归锁会记录当前被成功加了多少次锁，只有加锁和解锁次数一样，平衡时，这个锁最终才被释放，其他线程才能获得这个锁。递归锁通常用在递归函数内部防止递归操作阻塞线程。当然你也可以用在非递归的场合。</p>

<pre><code class="`">
- (void)recursiveFun:(int)count
{
    [self.recursiveLock lock];
    [self changeValue];
    if (count != 0) {
        count--;
        [self recursiveFun:count];
    }

    [self.recursiveLock unlock];
}
</code></pre>

<ul>
<li><code>5.NSConditionLock</code></li>
</ul>


<p><code>NSConditionLock</code> 定义了一个可以通过特殊的值来锁和解锁的互斥锁。不要和<code>Condition</code>搞混，虽然这种方式和条件很像，但是实现完全不同。特别是当线程之间需要需要按照一个特殊的顺序执行任务的时候，你应该使用<code>NSConditionLock</code>,比如一个线程生产数据，另一个消费数据。当生产者正在执行的时候，消费者用条件请求锁。当生产者完成后，解锁并设置条件，唤醒消费线程，去消费数据。
<code>NSConditionLock</code>的加锁和解锁方法可以各种组合。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>- (void)sendSharedData{
</span><span class='line'>    [self.conditionLock lock];
</span><span class='line'>    [self.sharedArray addObject:@1];
</span><span class='line'>    NSLog(@"添加数据 thread:%@",[NSThread currentThread]);
</span><span class='line'>    [self.conditionLock unlockWithCondition:1];
</span><span class='line'>    [NSThread sleepUntilDate:[NSDate dateWithTimeIntervalSinceNow:0.3]];
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>- (IBAction)conditionlock:(id)sender {
</span><span class='line'>    dispatch_async(dispatch_get_global_queue(0, 0), ^{
</span><span class='line'>        while (1) {
</span><span class='line'>            [self.conditionLock lockWhenCondition:1];
</span><span class='line'>            [self.sharedArray removeObjectAtIndex:0];
</span><span class='line'>            NSLog(@"消耗一个数据 thread:%@",[NSThread currentThread]);
</span><span class='line'>            BOOL isEmpty = self.sharedArray.count == 0 ? YES : NO;
</span><span class='line'>            [self.conditionLock unlockWithCondition:(isEmpty ? 0 : 1)];
</span><span class='line'>            [NSThread sleepUntilDate:[NSDate dateWithTimeIntervalSinceNow:2]];
</span><span class='line'>        }
</span><span class='line'>    });
</span><span class='line'>    
</span><span class='line'>    dispatch_async(dispatch_get_global_queue(0, 0), ^{
</span><span class='line'>        NSTimer *timer = [NSTimer scheduledTimerWithTimeInterval:0.5 target:self selector:@selector(sendSharedData) userInfo:nil repeats:YES];
</span><span class='line'>        [[NSRunLoop currentRunLoop] run];
</span><span class='line'>    });
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure>


<h4>Conditions 条件变量</h4>

<p>条件是另一种信号量，当满足某个条件的时候能允许其他线程运行。条件信号量主要用来表示某个资源可用个数，和保证线程安装固定的顺序运行。当一个线程需要某个condition的时候，会一直阻塞等待，直到只有当其他线程改变了条件信号量。互斥和条件信号量之间的区别是用条件信号量允许多个线程同时获得条件，运行。条件信号量就像门卫一样，根据资源的多少，决定让不同的线程可以进入。</p>

<h4>使用<code>Conditions</code></h4>

<p>条件是一种特殊类型的锁，它可以用来同步各个操作   顺序。条件和同步锁之间的区别很微妙。一个线程等待一个条件会阻塞，直到另外一个线程明确的发出条件信号。</p>

<ul>
<li><code>1.POSIX Conditions</code>
  <code>POSIX</code> 线程条件锁要求同时使用条件和互斥。运行时互斥锁约束条件，等待信号的线程使用同样的互斥和条件变量。</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (IBAction)distributedlock:(id)sender {
</span><span class='line'>    dispatch_async(dispatch_get_global_queue(0, 0), ^{
</span><span class='line'>        [self waitOnConditionfun];
</span><span class='line'>    });
</span><span class='line'>    dispatch_async(dispatch_get_global_queue(0, 0), ^{
</span><span class='line'>        [self signalThreadCondition];
</span><span class='line'>    });
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>- (void)waitOnConditionfun{
</span><span class='line'>    
</span><span class='line'>    // mutex 如果等待线程先获得mutex，加锁。那signal如何获得锁，又如何加锁呢。哦如果不成功，直接就解锁
</span><span class='line'>    pthread_mutex_lock(&mutex);
</span><span class='line'>    while (ready_to_go) {
</span><span class='line'>        NSLog(@"wait--thread:%@",[NSThread currentThread]);
</span><span class='line'>        pthread_cond_wait(&condition, &mutex);
</span><span class='line'>    }
</span><span class='line'>    ready_to_go = false;
</span><span class='line'>    pthread_mutex_unlock(&mutex);
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>- (void)signalThreadCondition{
</span><span class='line'>
</span><span class='line'>    // At this point, there should be work for the other thread to do.
</span><span class='line'>    pthread_mutex_lock(&mutex);
</span><span class='line'>    ready_to_go = true;
</span><span class='line'>    // Signal the other thread to begin work.
</span><span class='line'>    pthread_cond_signal(&condition);
</span><span class='line'>    NSLog(@"signal--thread:%@",[NSThread currentThread]);
</span><span class='line'>    pthread_mutex_unlock(&mutex);
</span><span class='line'>}
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li><code>2.NSCondition</code></li>
</ul>


<p><code>NSCondition</code>提供了和<code>POSIX condition</code>相同的功能，但是把请求锁和条件封装成一个对象，结果就是你只用它就可以实现互斥加锁和条件等待。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>- (IBAction)nscondition:(id)sender {
</span><span class='line'>    
</span><span class='line'>    dispatch_async(dispatch_get_global_queue(0, 0), ^{
</span><span class='line'>        while (1) {
</span><span class='line'>            [self.condition lock];
</span><span class='line'>            while (timeToWork &lt;= 0) {
</span><span class='line'>                [self.condition wait];
</span><span class='line'>            }
</span><span class='line'>            timeToWork--;
</span><span class='line'>            NSLog(@"消费数据--thread:%@",[NSThread currentThread]);
</span><span class='line'>            [self.condition unlock];
</span><span class='line'>        }
</span><span class='line'>    });
</span><span class='line'>
</span><span class='line'>    dispatch_async(dispatch_get_global_queue(0, 0), ^{
</span><span class='line'>        while (1) {
</span><span class='line'>            [self.condition lock];
</span><span class='line'>            timeToWork++;
</span><span class='line'>            NSLog(@"添加数据--thread:%@",[NSThread currentThread]);
</span><span class='line'>            [self.condition signal];
</span><span class='line'>            [self.condition unlock];
</span><span class='line'>            [NSThread sleepUntilDate:[NSDate dateWithTimeIntervalSinceNow:1]];
</span><span class='line'>        }
</span><span class='line'>    });
</span><span class='line'>}
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure>


<hr />

<h3>线程安全设计技巧</h3>

<ul>
<li>1.避免同步</li>
</ul>


<p>同步工具不是万灵药，锁用的太多会导致性能低于没有使用同步的程序。寻找线程安全和性能的平衡是需要经验。实现同步最好的方法是减小线程间的交互，让同步任务相互独立。如果每个任务操作自己私有数据，就不需要使用锁来保护数据。如果不同的任务共享一块数据，你可以尝试把数据分割，或复制一份数据，虽然这也消耗性能，你可以再决定前权衡一下。</p>

<ul>
<li>2.理解同步的限制</li>
</ul>


<p>同步工具只有被所有的线程一直使用才能最有效。如果创建一个互斥锁用来限制对某个资源的访问，你的所以线程必须请求相同的互斥变量才能操作这个数据。如果没达到这个效果，是一个程序员的错误！！！！</p>

<ul>
<li>3.正确编码的风险</li>
</ul>


<p>当使用锁的时候，你必须非常的小心的实现你的代码。因为锁可能看起来很好的实现了，但是还是存在安全问题。看下面的例子，</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSLock* arrayLock = GetArrayLock();
</span><span class='line'>NSMutableArray* myArray = GetSharedArray();
</span><span class='line'>id anObject;
</span><span class='line'> 
</span><span class='line'>[arrayLock lock];
</span><span class='line'>anObject = [myArray objectAtIndex:0];
</span><span class='line'>[arrayLock unlock];
</span><span class='line'> 
</span><span class='line'>[anObject doSomething];
</span></code></pre></td></tr></table></div></figure>


<p>上面的代码，因为array 是可变的，这个lock会一直保护这个array，知道你得到<code>anobject</code>,而且因为anobject 是不可变的，所以<code>[anObject doSomething];</code>不需要锁的保护。但是这段代码有个问题，就是当获得了<code>anb=object</code>后，但是还没执行<code>[anObject doSomething];</code>之前，另外一个线程获得了lock并且把<code>myarray</code>里面的元素全部删掉了，iOS没有内存垃圾机制的，所以<code>anobject</code>指向的对象会被释放，<code>anobject</code>指针会指向一个非法的地址，解决这个问题，你可能会把<code>[anObject doSomething];</code>也放在锁里面，但是这会消耗很长时间，导致其他线程会长时间的等待。正确的做法应该是，保证<code>anobject</code>不会被释放.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>NSLock* arrayLock = GetArrayLock();
</span><span class='line'>NSMutableArray* myArray = GetSharedArray();
</span><span class='line'>id anObject;
</span><span class='line'> 
</span><span class='line'>[arrayLock lock];
</span><span class='line'>anObject = [myArray objectAtIndex:0];
</span><span class='line'>[anObject retain];
</span><span class='line'>[arrayLock unlock];
</span><span class='line'> 
</span><span class='line'>[anObject doSomething];
</span><span class='line'>[anObject release];
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>4.小心死锁活锁</li>
</ul>


<p>任何时候一个线程一次想要获取多于一个锁，都有死锁的可能。死锁是两个线程分别获得一个锁后，又想去得到另外一个线程的锁。结果就是每个线程都会一直阻塞下去。以下是对死锁和活锁的形象描述。 现有个过道，两个人宽，两侧迎面走来两个人A和B。 死锁的情况： A和B都不是讲礼貌的人，都不愿给别人让路，所以A和B都在等对方让路，导致谁也过不去。 活锁的情况： A和B都是很讲礼貌的人，都主动给别人让路。A往左移，同时B往右移；A往右移，同时B往左移。 A和B在移动的时候，同时挡住对方，导致谁也过不去</p>

<ul>
<li><p>5.正确的使用验证变量</p>

<p>  如果你已经使用了互斥锁保护一段代码，就不要再使用验证关键字去保护代码中重要变量。互斥包括一个内存栅栏去确保读取和写入操作的次序。添加一个验证变量会导致强制读取值每次，降低性能。如果一个互斥锁足够的话，就不要再使用了。</p></li>
</ul>


<hr />

<h3>线程安全总结</h3>

<hr />

<h3>不同方法使用的场合，优缺点</h3>

<p>未完待续！！</p>

<p> <a href="https://github.com/githubdelegate/iOS-Thread-Synchronization.git">测试代码</a></p>

		
		
	</div>

</article>

</div>
<nav id="pagenavi">
    
    
        <a href="2" class="next">Next</a>
    
    <div class="center"><a href="/blog/archives">Blog Archives</a></div>
</nav></div>
			</div>
			<footer id="footer" class="inner">Copyright &copy; 2016

    zy


Design credit: <a href="http://shashankmehta.in/archive/2012/greyshade.html">Shashank Mehta</a></footer>
			<script src="/javascripts/slash.js"></script>
<script src="/javascripts/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
	$('.fancybox').fancybox();
})(jQuery);
</script> <!-- Delete or comment this line to disable Fancybox -->


<script type="text/javascript">
      var disqus_shortname = 'alpinezy';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>





		</div>
	</div>
</body>
</html>
