<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: swift | Alpine Blog]]></title>
  <link href="http://githubdelegate.github.io/blog/categories/swift/atom.xml" rel="self"/>
  <link href="http://githubdelegate.github.io/"/>
  <updated>2016-03-02T17:24:48+08:00</updated>
  <id>http://githubdelegate.github.io/</id>
  <author>
    <name><![CDATA[zy]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[oc转swift 错误记录]]></title>
    <link href="http://githubdelegate.github.io/blog/2016/01/04/oczhuan-swift-cuo-wu-ji-lu/"/>
    <updated>2016-01-04T14:34:43+08:00</updated>
    <id>http://githubdelegate.github.io/blog/2016/01/04/oczhuan-swift-cuo-wu-ji-lu</id>
    <content type="html"><![CDATA[<h2>1.option enum -> OptionSetType</h2>

<pre><code>rightView.autoresizingMask = UIViewAutoresizingFlexibleLeftMargin |UIViewAutoresizingFlexibleTopMargin;
</code></pre>

<p>转
<code>
self.rightView?.autoresizingMask = [.FlexibleTopMargin,.FlexibleLeftMargin]
</code></p>

<ul>
<li><p>MIN -> min</p></li>
<li><p>3.swift 闭包中的循环引用</p>

<blockquote><p><a href="http://southpeak.github.io/blog/2014/06/27/ios-swift-closures-2/">Swift闭包二：循环引用</a></p></blockquote></li>
<li><p>4.swift中和NSRange相关接口使用</p></li>
</ul>


<pre><code>let levels = "ABCDE"

let nsRange = NSMakeRange(1, 4)
// 编译错误
// 'NSRange' is not convertible to 'Range&lt;String.Index&gt;'
levels.stringByReplacingCharactersInRange(nsRange, withString: "AAAA")

let indexPositionOne = levels.startIndex.successor()
let swiftRange = indexPositionOne..&lt;advance(indexPositionOne, 4)
levels.stringByReplacingCharactersInRange(swiftRange, withString: "AAAA")
// 输出：
// AAAAA
</code></pre>

<p>上面的方法太麻烦啦。
<code>
let nsRange = NSMakeRange(1, 4)
(levels as NSString).stringByReplacingCharactersInRange(
    nsRange, withString: "AAAA")
</code></p>

<ul>
<li>5 中文转拼音</li>
</ul>


<pre><code>+ (NSString *)pinyinString:(NSString *)string
{

    NSMutableString *mutableString = [NSMutableString stringWithString:string];
    CFStringTransform((CFMutableStringRef)mutableString, NULL, kCFStringTransformToLatin, false);
    CFStringTransform((CFMutableStringRef)mutableString, NULL, kCFStringTransformStripDiacritics, false);
    NSLog(@"%@",mutableString);
    return mutableString;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[swift 中单例的实现]]></title>
    <link href="http://githubdelegate.github.io/blog/2015/12/14/swift-zhong-dan-li-de-shi-xian/"/>
    <updated>2015-12-14T18:54:44+08:00</updated>
    <id>http://githubdelegate.github.io/blog/2015/12/14/swift-zhong-dan-li-de-shi-xian</id>
    <content type="html"><![CDATA[<h1>Swift单例</h1>

<p>Use the <strong>class constant</strong> approach if you are using Swift 1.2 or above and the <strong>nested struct</strong> approach if you need to support earlier versions._</p>

<p>An exploration of the Singleton pattern in Swift. All approaches below support lazy initialization and thread safety.</p>

<p>Issues and pull requests welcome.</p>

<h3>Approach A: Class constant</h3>

<pre><code>class SingletonA {

    static let sharedInstance = SingletonA()

    init() {
        println("AAA");
    }

}
</code></pre>

<p>This approach supports lazy initialization because Swift lazily initializes class constants (and variables), and is thread safe by the definition of <code>let</code>.</p>

<p>Class constants were introduced in Swift 1.2. If you need to support an earlier version of Swift, use the nested struct approach below or a global constant.</p>

<h3>Approach B: Nested struct</h3>

<pre><code>class SingletonB {

    class var sharedInstance: SingletonB {
        struct Static {
            static let instance: SingletonB = SingletonB()
        }
        return Static.instance
    }

}
</code></pre>

<p>在类变量里嵌套一个 <code>Static</code> 结构体。
<code>Static</code> 封装了一个静态的常量，通过 static 定义意味着这个属性只存在一个，注意 Swift 中 static 的变量是延时加载的，意味着 Instance 直到需要的时候才会被创建。同时再注意一下，因为它是一个常量，所以一旦创建之后不会再创建第二次。这些就是单例模式的核心所在：一旦初始化完成，当前类存在一个实例对象，初始化方法就不会再被调用。</p>

<p>Here we are using the static constant of a nested struct as a class constant. This is a workaround for the lack of static class constants in Swift 1.1 and earlier, and still works as a workaround for the lack of static constants and variables in functions.</p>

<h3>Approach C: dispatch_once</h3>

<p>The traditional Objective-C approach ported to Swift.</p>

<pre><code>class SingletonC {

    class var sharedInstance: SingletonC {
        struct Static {
            static var onceToken: dispatch_once_t = 0
            static var instance: SingletonC? = nil
        }
        dispatch_once(&amp;Static.onceToken) {
            Static.instance = SingletonC()
        }
        return Static.instance!
    }
}
</code></pre>

<p>I&rsquo;m fairly certain there&rsquo;s no advantage over the nested struct approach but I&rsquo;m including it anyway as I find the differences in syntax interesting.</p>
]]></content>
  </entry>
  
</feed>
